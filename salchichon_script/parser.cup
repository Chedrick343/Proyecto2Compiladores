package salchichon_script;

import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.ArrayList;

// PARSER
parser code
{:
    public class NodoToken{
        String tipo;
        String id;
        String valor;
        String linea;
        String columna;
        public NodoToken() {
        }

        public String getTipo() {
            return tipo;
        }

        public void setTipo(String tipo) {
            this.tipo = tipo;
        }
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getValor() {
            return valor;
        }

        public void setValor(String valor) {
            this.valor = valor;
        }

        public String getLinea() {
            return linea;
        }

        public void setLinea(String linea) {
            this.linea = linea;
        }

        public String getColumna() {
            return columna;
        }

        public void setColumna(String columna) {
            this.columna = columna;
        }
        @Override
        public String toString() {
            return "NodoToken \n{\n" +
                " tipo = " + tipo + '\n' +
                " id = " + id + '\n' +
                " valor = " + valor + '\n' +
                " linea = " + linea + '\n' +
                " columna = " + columna + '\n' +
            '}';
        }
    }

    HashMap<String, ArrayList<NodoToken>> listaTablasSimbolos = new HashMap<>();
    String currentHash;
    String globalHash = "global1TS";
    int contadorLoop = 0;
    int contadorFor = 0;
    int contadorDecide = 0;
    int contadorCase = 0;
    int contadorElse = 0;

    public void inicarTS() {
        listaTablasSimbolos.put(globalHash, new ArrayList<>());
        currentHash = globalHash;

        NodoToken printFunc = new NodoToken();
        printFunc.setTipo("funcion_sistema");
        printFunc.setId("imprimir");
        printFunc.setValor("void");
        printFunc.setLinea("0");
        printFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(printFunc);

        NodoToken readFunc = new NodoToken();
        readFunc.setTipo("funcion_sistema");
        readFunc.setId("leer");
        readFunc.setValor("string");
        readFunc.setLinea("0");
        readFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(readFunc);
    }

    public void imprimirTablasSimbolos(){
        for(String key: listaTablasSimbolos.keySet()){
            System.out.println("------------------Tabla de simbolo : " + key);
            System.out.println("********Valores*********** ");
            for(NodoToken item : listaTablasSimbolos.get(key)){
                System.out.println(item.toString());
        }
            System.out.println("------------------Fin tabla de simbolos : " + key);
        }
    }
    
    public String getTipo(ArrayList<NodoToken> tabla, String id){
        String tipo = "";
        for(NodoToken token : tabla){
            if(id.equals(token.getValor())){
                tipo = token.getTipo();
            }
        }
        System.out.println("tipo: "+tipo);
        return tipo;
    }

    public NodoToken buscarID(String id){
        System.out.println(">>> [DEBUG] Buscando ID: '" + id + "' en ámbito: " + currentHash);
        
        if(listaTablasSimbolos.containsKey(currentHash)){
            for(NodoToken tok : listaTablasSimbolos.get(currentHash)){
                if(tok.getId().equals(id)) {
                    System.out.println(">>> [DEBUG] Encontrado en ámbito actual: " + tok.getId() + " = " + tok.getValor());
                    return tok;
                }
            }
        }
        
        for(NodoToken tok : listaTablasSimbolos.get(globalHash)){
            if(tok.getId().equals(id)) {
                System.out.println(">>> [DEBUG] Encontrado en ámbito global: " + tok.getId() + " = " + tok.getValor());
                return tok;
            }
        }
        
        System.out.println(">>> [DEBUG] NO encontrado: " + id);
        return null;
    }

    public boolean tieneErrores = false;

    // Para recordar última posición válida
    private int lastLine = 1;
    private int lastColumn = 1;

    // Guardar última posición válida después de cada token leído
    @Override
    public Symbol scan() throws Exception {
        Symbol sym = super.scan();
        if (sym != null) {
            if (sym.left >= 0) lastLine = sym.left + 1;
            if (sym.right >= 0) lastColumn = sym.right + 1;
        }
        return sym;
    }

    // Errores recuperables
    @Override
    public void syntax_error(Symbol s) {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m XXX Error sintáctico recuperable XXX :       Token '%s' en línea %d, columna %d.\u001B[0m %n", lexema, linea, columna);
    }

    // Errores no recuperables
    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m     XXX Error sintáctico crítico XXX :       Token '%s' en línea %d, columna %d. \u001B[0m %n", lexema, linea, columna);
    }
:}

action code
{:
    // Codigo de usuario - fase de analisis
    String tmp="";
:}

// TERMINALES
terminal PAR_A, PAR_C, BLO_A, BLO_C, COMA, FLECHA, FIN_E, ASIGN, COR_A, COR_C, COMILLA_SIMP, CADENA_CHAR;
terminal MAS, MENOS, POR, DIV, DIV_ENT, MOD, POT;
terminal AND, OR, NOT;
terminal INC, DEC;
terminal MAYOR, MENOR, MAY_IGU, MEN_IGU, IGUAL, DIF;
terminal INT1, CHAR1, STR1, FLOAT1, BOOL1, LET, VOID, TRUE1, FALSE1, DECIDE;
terminal OF, ELSE, END, LOOP, EXIT, WHEN, FOR1, STEP, TO, DOWNTO, DO;
terminal RETURN, BREAK;
terminal INIT;

terminal ENTERO, FLOTANTE, CHAR, ID;
terminal IMPRIMIR, LEER, MAIN, CADENA;

// NO TERMINALES
non terminal Object program;
non terminal main_funcion, elemento_global, lista_global;
non terminal String tipo, tipo_funcion;
non terminal declaracion;
non terminal bloque, lista_sentencias, lista_sentencias_opt, sentencia, expr_opc, llamada_funcion, parametros_llamada, imprimir, leer;
non terminal funcion, parametros_opt, lista_parametros, parametro;
non terminal asignacion, asignacion_dec;
non terminal expresion;
non terminal expresion_arit, termino, factor, potencia, operando, elem_arr;
non terminal op_rel, incrementar, decrementar;
non terminal condicional, lista_casos, caso, cond_else_opt, bucle_loop, bucle_for, step, direccion;
non terminal lista_elementos_arreglo_entero, lista_char, diferente_asignacion, arreglo_char, declaracion_arreglo_entero, declaracion_arreglo_char, asignacion_arreglo_entero, asignacion_arreglo_char; 
non terminal declara_func, declara_main_func;

// PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left IGUAL, DIF;
precedence left MAYOR, MENOR, MAY_IGU, MEN_IGU;
precedence left MAS, MENOS;
precedence left POR, DIV, DIV_ENT, MOD;
precedence right POT;
precedence right NOT;

// PRODUCCIONES

start with program;

program ::= {:  
                System.out.println("generando tabla de símbolos");
                inicarTS();
            :}
                lista_global main_funcion lista_global
            {:
                imprimirTablasSimbolos();
                System.out.println("fin de ejecución");
            :}
            ;
            
lista_global ::= elemento_global lista_global
    | /* vacío */
    ;

elemento_global ::= sentencia
    | funcion
    {: System.out.println("Fin variables globales"); :}
    ;

main_funcion ::= declara_main_func PAR_A PAR_C bloque
    | declara_main_func bloque
    | declara_main_func error
    ;

declara_main_func ::= INIT VOID:tipo MAIN:main
{:
    NodoToken func = new NodoToken();
    func.setId(main.toString());
    func.setTipo(tipo.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + main.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función main creada: " + currentHash);
:};

// ======== DECLARACIÓN DE VARIABLES ========
tipo ::= INT1 {: RESULT = "int"; :}
    | STR1 {: RESULT = "string"; :}
    | FLOAT1 {: RESULT = "float"; :}
    | BOOL1 {: RESULT = "boolean"; :}
    | CHAR1 {: RESULT = "char"; :}
    ;

tipo_funcion ::= tipo:t {: RESULT = t; :}
    | VOID {: RESULT = "void"; :}
    ;

//+++++++++++++++++++++BLOQUE++++++++++++++++++++++++++++++++++

bloque ::= BLO_A lista_sentencias_opt BLO_C
         | BLO_A error BLO_C
         ;

lista_sentencias_opt ::= /* vacío */
                     | lista_sentencias
                     ;

lista_sentencias ::= sentencia
                  | lista_sentencias sentencia
                  ;
                  
sentencia ::= declaracion FIN_E
    | declaracion_arreglo_entero FIN_E
    | declaracion_arreglo_char FIN_E
    | asignacion_arreglo_entero FIN_E
    | asignacion_arreglo_char FIN_E
    | asignacion FIN_E
    | llamada_funcion FIN_E
    | imprimir FIN_E
    | leer FIN_E
    | RETURN expr_opc FIN_E
    | BREAK FIN_E
    | incrementar FIN_E
    | decrementar FIN_E
    | condicional FIN_E
    | bucle_loop 
    | bucle_for
    | error FIN_E
    ;

incrementar ::= ID INC;
decrementar ::= ID DEC;

expr_opc ::=
      expresion
    | /* ε */
    ;

llamada_funcion ::= ID PAR_A parametros_llamada PAR_C;

parametros_llamada ::= expresion
                        | expresion COMA parametros_llamada
                        |
                        ;

imprimir ::= IMPRIMIR PAR_A expresion:e PAR_C
{:
    NodoToken imp = new NodoToken();
    imp.setTipo("llamada_funcion_sistema");
    imp.setId("imprimir");
    imp.setValor(e != null ? e.toString() : "");
    imp.setLinea(String.valueOf(lastLine));
    imp.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(imp);
    System.out.println(">>> [DEBUG] Uso de imprimir() en " + currentHash + " con valor: " + imp.getValor());
:};

leer ::= LEER PAR_A PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("entrada_usuario");
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash);
:}
| LEER PAR_A ID:var PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("asigna_a:" + var.toString());
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash + ", asignando a " + var);
:};


//+++++++++++++++++++++FUNCIONES++++++++++++++++++++++++++++++++

funcion ::= declara_func PAR_A parametros_opt:params PAR_C
             bloque
             {:
                currentHash = globalHash;
                System.out.println(">> [TS] Regresando a tabla global.");
            :}
          | declara_func PAR_A parametros_opt PAR_C error
          ;

declara_func::= tipo_funcion:tipoFun ID:nombreFun
{:
    NodoToken func = new NodoToken();
    func.setId(nombreFun.toString());
    func.setTipo(tipoFun.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + nombreFun.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función creada: " + currentHash);
:};

parametros_opt ::= lista_parametros
                 | // VACIO
                 ;

lista_parametros ::= parametro
                  | lista_parametros COMA parametro
                  ;

parametro ::= tipo:ti ID:nombreParam
    {:
        NodoToken param = new NodoToken();
        param.setTipo(ti);
        param.setId(nombreParam.toString());
        param.setLinea(String.valueOf(lastLine));
        param.setColumna(String.valueOf(lastColumn));
        listaTablasSimbolos.get(currentHash).add(param);
        System.out.println(">>> [DEBUG] Parámetro agregado: " + nombreParam.toString() + " en " + currentHash);
    :};

//+++++++++++++++++++++DECLARACIONES Y ASIGNACIONES+++++++++++++++

// VERSIÓN SIMPLIFICADA - DECLARACIONES SEPARADAS
declaracion ::= LET tipo:tipoDato ID:nombreDeclaracion 
{:
    // Declaración SIN asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo(tipoDato);
    declaracion.setId(nombreDeclaracion.toString());
    declaracion.setValor(""); // Valor vacío por defecto
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
    System.out.println(">>> [DEBUG] Variable declarada SIN valor: " + nombreDeclaracion.toString() + " en " + currentHash);
:} 
| LET tipo:tipoDato ID:nombreDeclaracion ASIGN expresion:valorExpr
{:
    // Declaración CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo(tipoDato);
    declaracion.setId(nombreDeclaracion.toString());
    
    if (valorExpr != null) {
        String valorStr = valorExpr.toString();
        declaracion.setValor(valorStr);
        System.out.println(">>> [DEBUG] Variable declarada CON valor: " + nombreDeclaracion.toString() + " = " + valorStr + " en " + currentHash);
    } else {
        declaracion.setValor("");
        System.out.println(">>> [DEBUG] Variable declarada CON valor NULL: " + nombreDeclaracion.toString() + " en " + currentHash);
    }
    
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
:}
;
declaracion_arreglo_entero ::= LET tipo ID:nombreArreglo COR_A ENTERO COR_C ASIGN COR_A lista_elementos_arreglo_entero:elementos COR_C
{:
    // Declaración de arreglo de enteros CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_entero");
    declaracion.setId(nombreArreglo.toString());
    
    StringBuilder elementosStr = new StringBuilder();
    elementosStr.append("[");
    
    if (elementos != null && elementos instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) elementos;
        for (int i = 0; i < elementosLista.size(); i++) {
            if (i > 0) elementosStr.append(", ");
            elementosStr.append(elementosLista.get(i));
        }
        System.out.println(">>> [DEBUG] Arreglo con " + elementosLista.size() + " elementos: " + elementosStr.toString());
    } else {
        elementosStr.append("]");
        System.out.println(">>> [DEBUG] Arreglo sin elementos válidos");
    }
    
    elementosStr.append("]");
    
    declaracion.setValor(elementosStr.toString());
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
    System.out.println(">>> [DEBUG] Arreglo de enteros declarado CON valor: " + nombreArreglo.toString() + " = " + elementosStr.toString() + " en " + currentHash);
:}
;

declaracion_arreglo_char ::= LET tipo ID:nombreArregloChar COR_A ENTERO COR_C ASIGN arreglo_char:valoresChar
{:
    // Declaración de arreglo de chars CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_char");
    declaracion.setId(nombreArregloChar.toString());
    
    if (valoresChar != null) {
        String valorStr = valoresChar.toString();
        declaracion.setValor(valorStr);
        System.out.println(">>> [DEBUG] Arreglo de chars declarado CON valor: " + nombreArregloChar.toString() + " = " + valorStr + " en " + currentHash);
    } else {
        declaracion.setValor("arreglo_char");
        System.out.println(">>> [DEBUG] Arreglo de chars declarado SIN valor específico: " + nombreArregloChar.toString() + " en " + currentHash);
    }
    
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
:}
;

lista_char ::= CHAR:caracter {: 
    RESULT = caracter.toString();
:}
| lista_char:lista COMA CHAR:caracter {: 

    String listaStr = lista.toString() + ", " + caracter.toString();
    RESULT = listaStr;
:}
;

arreglo_char ::= COR_A lista_char:lista COR_C {: 
    String resultado = "[" + lista.toString() + "]";
    RESULT = resultado;
:};

asignacion ::= ID:nombre ASIGN expresion:valor
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            if(valor != null){
                String valorStr = valor.toString();
                variable.setValor(valorStr);
            } else {
                variable.setValor("");
            }
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
    :}
    | ID:nombre COR_A ENTERO COR_C ASIGN ENTERO:valorArr
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            variable.setValor("arreglo_entero[" + valorArr + "]");
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
    :}
    | ID:nombre COR_A ENTERO COR_C ASIGN arreglo_char:valorChar
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            variable.setValor("arreglo_char");
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
    :}
    ;
// EXPRESIONES
expresion ::= expresion AND expresion
    | expresion OR expresion
    | NOT expresion
    | expresion_arit op_rel expresion
    | expresion_arit:e {: RESULT = e;:}
    ;

// EXPRESIONES ARITMETICAS
expresion_arit ::= expresion_arit MAS termino
    | expresion_arit MENOS termino
    | termino:t {: RESULT = t; :}
    ;

termino ::= factor POR factor
    | factor DIV factor
    | factor DIV_ENT factor
    | factor MOD factor
    | factor:f {: RESULT = f; :}
    ;

factor ::= potencia POT potencia
    | potencia:p {: RESULT = p; :}
    ;

potencia ::= PAR_A expresion PAR_C
    | operando:o {: RESULT = o; :}
    ;
    
//UN OPERANDO ES LA FORMA MÁS SENCILLA DE UNA OPERACIÓN
operando ::= ENTERO:a {: 
    RESULT = a; 
:}
| FLOTANTE:f {: 
    RESULT = f; 
:}
| TRUE1 {: 
    RESULT = "true"; 
:}
| FALSE1 {: 
    RESULT = "false"; 
:}
| CADENA_CHAR:c {: 
    RESULT = c; 
:}
| CADENA:s {: 
    RESULT = s; 
:}
| ID:id {: 
    RESULT = id.toString();
    // Verificar que la variable existe
    NodoToken variable = buscarID(id.toString());
    if (variable == null) {
        System.err.printf("\u001B[31m XXX Error semántico XXX :       Variable '%s' no declarada en expresión. Línea %d, columna %d.\u001B[0m %n", id.toString(), lastLine, lastColumn);
        tieneErrores = true;
    }
:} 
| llamada_funcion:llamada {: 
    RESULT = llamada; 
:}
| elem_arr
| MENOS operando:op {: 
    if (op != null) {
        String resultado = "-" + op.toString();
        RESULT = resultado;
    } else {
        RESULT = null;
    }
:}
| incrementar
| decrementar
;

// OPERADORES RELACIONALES
op_rel ::= MAYOR
    | MENOR
    | MAY_IGU
    | MEN_IGU
    | IGUAL
    | DIF
    ;

// ESTRUCTURAS DE CONTROL 

// TO-DO: arbol sintáctico para condicionales y bucles

condicional ::=
    DECIDE OF
    {:
        // AQUI SE CREA EL SCOPE PARA EL BLOQUE DECIDE
        contadorDecide++;
        String decideScope = currentHash + "_DECIDE_" + contadorDecide;
        listaTablasSimbolos.put(decideScope, new ArrayList<>());
        System.out.println(">>> [DEBUG] Inicia ámbito DECIDE: " + decideScope);
        
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = decideScope;

        RESULT = anteriorScope;
    :}
    lista_casos
    cond_else_opt
    END DECIDE
    {:
        // recuperar el scope en el que estaba antes
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito DECIDE, regresando a: " + currentHash);
    :}
    ;

lista_casos ::= caso
              | lista_casos caso
              ;

caso ::=
    PAR_A expresion PAR_C FLECHA
    {:
        // SCOPE POR CADA CASO
        contadorCase++;
        String caseScope = currentHash + "_CASE_" + contadorCase;
        listaTablasSimbolos.put(caseScope, new ArrayList<>());
        System.out.println(">>> [DEBUG] Inicia ámbito CASE: " + caseScope);

        String anteriorScope = currentHash;
        currentHash = caseScope;
        RESULT = anteriorScope;
    :}
    bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito CASE, regresando a: " + currentHash);
    :}
    ;

cond_else_opt ::=
      /* vacío */
    | ELSE FLECHA
    {:
        contadorElse++;
        String elseScope = currentHash + "_ELSE_" + contadorElse;
        listaTablasSimbolos.put(elseScope, new ArrayList<>());
        System.out.println(">>> [DEBUG] Inicia ámbito ELSE: " + elseScope);

        String anteriorScope = currentHash;
        currentHash = elseScope;
        RESULT = anteriorScope;
    :}
      bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito ELSE, regresando a: " + currentHash);
    :}
    ;

bucle_loop ::=
    LOOP
    {:
        // Crear scope de tabla de símbolos 
        contadorLoop++;
        String loopScope = currentHash + "_LOOP_" + contadorLoop;
        listaTablasSimbolos.put(loopScope, new ArrayList<>());
        System.out.println(">>> [DEBUG] Inicia ámbito LOOP: " + loopScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = loopScope;
        RESULT = anteriorScope;
    :}
    lista_sentencias
    EXIT WHEN expresion FIN_E
    END LOOP FIN_E
    {:
        // Restaurar el scope previo
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito LOOP, regresando a: " + currentHash);
    :}
    ;

bucle_for ::= FOR1 asignacion step ENTERO direccion expresion DO bloque;

bucle_for ::=
    FOR1
    {:
        // Crear scope de el for al que se acceda
        contadorFor++;
        String forScope = currentHash + "_FOR_" + contadorFor;
        listaTablasSimbolos.put(forScope, new ArrayList<>());
        System.out.println(">>> [DEBUG] Inicia ámbito FOR: " + forScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = forScope;
        RESULT = anteriorScope;
    :}
    asignacion
    step ENTERO
    direccion expresion
    DO bloque
    {:
        // Recupera el scope anterior
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito FOR, regresando a: " + currentHash);
    :}
    ;

step ::= /* vacío */
       | STEP
       ;

direccion ::= TO
            | DOWNTO
            ;

//++++++++++++++++++++++++++++++++ARREGLOS+++++++++++++++++++++++++++++

lista_elementos_arreglo_entero ::= ENTERO:entero {: 
    // Primer elemento
    ArrayList<String> elementos = new ArrayList<>();
    elementos.add(entero.toString());
    RESULT = elementos;
    System.out.println(">>> [DEBUG] Primer elemento del arreglo: " + entero);
:}
| lista_elementos_arreglo_entero:lista COMA ENTERO:entero {: 
    // Agregar elemento a la lista existente
    if (lista != null && lista instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) lista;
        elementosLista.add(entero.toString());
        RESULT = elementosLista;
        System.out.println(">>> [DEBUG] Agregando elemento al arreglo: " + entero + ", total: " + elementosLista.size());
    } else {
        // Si por alguna razón la lista no es válida, crear una nueva
        ArrayList<String> elementos = new ArrayList<>();
        elementos.add(entero.toString());
        RESULT = elementos;
        System.out.println(">>> [DEBUG] Creando nueva lista con elemento: " + entero);
    }
:}
;
package salchichon_script;

import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.io.FileWriter;

// PARSER
parser code
{:
    /**
    * Representa una entrada en la tabla de símbolos (token semántico) de Salchichón Script.
    * Guarda tipo, identificador, valor y metadatos de posición (línea/columna).
    */
    public class NodoToken{
        String tipo;
        String id;
        String valor;
        String linea;
        String columna;
        List<String> parametros;

        /** Crea un nodo vacío (campos nulos). */
        public NodoToken() {
            parametros = new ArrayList<>();
        }

        /** @return el tipo semántico del símbolo. */
        public String getTipo() {
            return tipo;
        }

        /** @param tipo nuevo tipo semántico. */
        public void setTipo(String tipo) {
            this.tipo = tipo;
        }

        /** @return el identificador (nombre) del símbolo. */
        public String getId() {
            return id;
        }

        /** @param id nuevo identificador. */
        public void setId(String id) {
            this.id = id;
        }

        /** @return el valor asociado al símbolo. */
        public String getValor() {
            return valor;
        }

        /** @param valor nuevo valor semántico. */
        public void setValor(String valor) {
            this.valor = valor;
        }

        /** @return línea 1-based en el archivo fuente. */
        public String getLinea() {
            return linea;
        }

        /** @param linea línea 1-based en el archivo fuente. */
        public void setLinea(String linea) {
            this.linea = linea;
        }

        /** @return columna 1-based en el archivo fuente. */
        public String getColumna() {
            return columna;
        }

        /** @param columna columna 1-based en el archivo fuente. */
        public void setColumna(String columna) {
            this.columna = columna;
        }
        
        public List<String> getParametros() {
            return parametros;
        }

        public void setParametros(List<String> parametros) {
            this.parametros = parametros;
        }

        public void addParametro(String parametro) {
            if (this.parametros == null) {
                this.parametros = new ArrayList<>();
            }
            this.parametros.add(parametro);
        }

        /** @return representación legible del símbolo y sus metadatos. */
        @Override
        public String toString() {
            return "NodoToken \n{\n" +
                " tipo = " + tipo + '\n' +
                " id = " + id + '\n' +
                " valor = " + valor + '\n' +
                " linea = " + linea + '\n' +
                " columna = " + columna + '\n' +
                " parametros = " + (parametros != null ? parametros.toString() : "[]") + '\n' +
            '}';
        }
    }

    HashMap<String, ArrayList<NodoToken>> listaTablasSimbolos = new HashMap<>();
    String currentHash;
    String globalHash = "global1TS";


    /**
    * Inicializa la tabla de símbolos global y registra funciones de sistema
    * disponibles por defecto (imprimir/leer).
    * Efectos: Crea el scope global, lo establece como actual y agrega
    * dos entradas de tipo "funcion_sistema".
    */
public void inicarTS() {
    listaTablasSimbolos.put(globalHash, new ArrayList<>());
    currentHash = globalHash;

    NodoToken printFunc = new NodoToken();
    printFunc.setTipo("funcion_sistema");
    printFunc.setId("imprimir");
    printFunc.setValor("void");
    printFunc.setLinea("0");
    printFunc.setColumna("0");
    listaTablasSimbolos.get(globalHash).add(printFunc);

    NodoToken readFunc = new NodoToken();
    readFunc.setTipo("funcion_sistema");
    readFunc.setId("leer");
    readFunc.setValor("string");
    readFunc.setLinea("0");
    readFunc.setColumna("0");
    listaTablasSimbolos.get(globalHash).add(readFunc);
}

    /**
    * Vuelca todas las tablas de símbolos a un archivo de texto (tokens.txt)
    * en formato legible.
    * Efectos: Escribe en disco. No altera el estado semántico.
    * Errores: Registra en consola si no se puede escribir el archivo.
    */
    public void imprimirTablasSimbolos(){
        try{
        FileWriter writer = new FileWriter("tokens.txt");
        for(String key: listaTablasSimbolos.keySet()){

            writer.write("Tabla de simbolos: " + key + "\n");
            writer.write("********Valores*********** \n");
            for(NodoToken item : listaTablasSimbolos.get(key)){
                writer.write(item.toString() + "\n");
            }
            writer.write("------------------Fin tabla de simbolos : " + key + "\n\n");
        }
        writer.close();
        }catch(Exception e){
        System.out.println("Error al escribir el archivo de tokens: " + e.getMessage());
    }
}

    /**
    * Busca el tipo asociado a un identificador dentro de una tabla específica.
    * @param tabla tabla de símbolos a inspeccionar.
    * @param id    identificador cuyo tipo se desea recuperar (comparado contra {token.valor}).
    * @return tipo encontrado o cadena vacía si no existe coincidencia.
    */
    public String getTipo(ArrayList<NodoToken> tabla, String id){
        String tipo = "";
        for(NodoToken token : tabla){
            if(id.equals(token.getValor())){
                tipo = token.getTipo();
            }
        }

        return tipo;
    }

    /**
    * Busca un identificador primero en el ámbito actual y luego en el global.
    * @param id identificador (nombre) a buscar.
    * @return el {NodoToken} si existe; de lo contrario {null}.
    */
    public NodoToken buscarID(String id){
        
        if(listaTablasSimbolos.containsKey(currentHash)){
            for(NodoToken tok : listaTablasSimbolos.get(currentHash)){
                if(tok.getId().equals(id)) {
                    return tok;
                }
            }
        }
        
        for(NodoToken tok : listaTablasSimbolos.get(globalHash)){
            if(tok.getId().equals(id)) {
                return tok;
            }
        }
        
        return null;
    }

    /**
    * Crea un nuevo ámbito (scope) copiando todos los símbolos visibles del
    * ámbito actual, y lo registra en {#listaTablasSimbolos}.
    * @param nombreScope nombre único del nuevo ámbito.
    * Efectos: No cambia {#currentHash}; solo registra el nuevo scope con símbolos heredados.
    */
    public void crearSubAmbito(String nombreScope) {
        ArrayList<NodoToken> nuevo = new ArrayList<>();

        // Copiar los simbolos anteriores al nuevo scope
        if (listaTablasSimbolos.containsKey(currentHash)) {
            for (NodoToken tok : listaTablasSimbolos.get(currentHash)) {
                NodoToken copia = new NodoToken();
                copia.setTipo(tok.getTipo());
                copia.setId(tok.getId());
                copia.setValor(tok.getValor());
                copia.setLinea(tok.getLinea());
                copia.setColumna(tok.getColumna());
                nuevo.add(copia);
            }
        }

        // Registrar el nuevo scope con los simbolos heredados
        listaTablasSimbolos.put(nombreScope, nuevo);

    }


    StringBuilder codigoIntermedio = new StringBuilder();
    int tempCont = 0;
    int floatTempCont = 0;
        
    StringBuilder target3D = codigoIntermedio;

    String scopeAnteriorDecide;
    String decideBaseLabel = null;
    StringBuilder decideConds = null;
    StringBuilder decideBlocks = null;

    int contadorLoop = 0;
    int contadorFor = 0;
    int contadorDecide = 0;
    int contadorCase = 0;
    int contadorElse = 0;

    /**
    * Genera el nombre de un temporal entero único (t1, t2, ...).
    * @return identificador del temporal generado.
    */
    String nuevaTempInt() {
        return "t" + (++tempCont);
    }

    /**
    * Genera el nombre de un temporal de punto flotante único (f1, f2, ...).
    * @return identificador del temporal generado.
    */
    String nuevaTempFloat() {
        return "f" + (++floatTempCont);
    }

    /**
    * Añade una línea de código de tres direcciones al buffer.
    * @param codigo instrucción 3AC ya formateada.
    */
    void cod3D(String codigo) {
        if (target3D == null) {
            target3D = codigoIntermedio;
        }
        target3D.append(codigo).append("\n");
    }

    /**
    * Emite 3AC para una operación binaria con carga de operandos a temporales si hace falta.
    * @param op1      operando izquierdo (temporal existente o nombre/valor literal).
    * @param operador símbolo del operador (p.ej., "+", "-", "*", "/", "%", "&&", "||", "^").
    * @param op2      operando derecho (temporal existente o nombre/valor literal).
    * @return nombre del temporal resultado.
    */
    public String genOperacion3D(String op1, String operador, String op2) {
        String temp1, temp2, tempRes;
        String tipo1, tipo2;

        // ===== Operando izquierdo =====
        if (op1.startsWith("t") || op1.startsWith("f")) {
            temp1 = op1;
            tipo1 = op1.startsWith("f") ? "float" : "int";
        } else {
            tipo1 = obtenerTipoExpresion(op1);        // literal o id
            if ("float".equals(tipo1)) {
                temp1 = nuevaTempFloat();
            } else {
                temp1 = nuevaTempInt();
            }
            cod3D(temp1 + " = " + op1);
        }

        // ===== Operando derecho =====
        if (op2.startsWith("t") || op2.startsWith("f")) {
            temp2 = op2;
            tipo2 = op2.startsWith("f") ? "float" : "int";
        } else {
            tipo2 = obtenerTipoExpresion(op2);
            if ("float".equals(tipo2)) {
                temp2 = nuevaTempFloat();
            } else {
                temp2 = nuevaTempInt();
            }
            cod3D(temp2 + " = " + op2);
        }

        // ===== Tipo del resultado =====
        String tipoRes;
        if ("float".equals(tipo1) || "float".equals(tipo2)) {
            tipoRes = "float";
        } else {
            tipoRes = "int";
        }

        if ("float".equals(tipoRes)) {
            tempRes = nuevaTempFloat();
        } else {
            tempRes = nuevaTempInt();
        }

        cod3D(tempRes + " = " + temp1 + " " + operador + " " + temp2);
        return tempRes;
    }



    // ==================== Validacion semantica ====================

    /**
    * Obtiene el tipo de retorno de la función actual.
    * Busca la función en la tabla de símbolos global usando el nombre de la función
    * derivado de `currentHash`.
    * 
    * @return El tipo de retorno de la función actual (por ejemplo, "int", "void", etc.).
    *         Si no se encuentra la función, retorna "desconocido".
    */
    public String obtenerTipoDeFuncionActual() {
        // Obtener el nombre de la función actual (supone que currentHash es el nombre de la función)
        String nombreFuncion = currentHash.replace("TS_FUNC_", "");
        
        // Buscar la función en la tabla de símbolos
        for (NodoToken token : listaTablasSimbolos.get(globalHash)) {
            if (token.getId().equals(nombreFuncion)) {
                // Si encontramos la función, devolvemos su tipo (el tipo de retorno)
                return token.getTipo();
            }
        }
        return "desconocido";  // Si no se encuentra la función, retornamos "desconocido"
    }


    /**
    * Valida que el valor literal/asignado sea compatible con el tipo declarado.
    * @param tipoEsperado tipo declarado de la variable destino (int, float, boolean, char, string).
    * @param valorAsignado representación textual del valor/expresión ya reducida.
    * @param linea línea de la fuente (1-based) para diagnóstico.
    * @param columna columna de la fuente (1-based) para diagnóstico.
    * 
    * Efectos: Marca {#tieneErrores} y escribe errores si hay incompatibilidades.
    */
    public void validarAsignacionTipo(String tipoEsperado, String valorAsignado, int linea, int columna) {
        if (valorAsignado == null || tipoEsperado == null) return;

        // 1) Inferir el tipo real de la expresión
        String tipoExpr = obtenerTipoExpresion(valorAsignado);

        // Si no se pudo inferir
        if ("desconocido".equals(tipoExpr)) {
            System.err.printf(
                "\u001B[33m [ADVERTENCIA] No se pudo inferir el tipo de la expresión '%s' para validar contra '%s'. Línea %d, columna %d.\u001B[0m%n",
                valorAsignado, tipoEsperado, linea, columna
            );
            return;
        }

        boolean ok = false;

        switch (tipoEsperado) {
            case "int":
                ok = "int".equals(tipoExpr);
                break;

            case "float":
                ok = "float".equals(tipoExpr) || "int".equals(tipoExpr);
                break;

            case "boolean":
                ok = "boolean".equals(tipoExpr);
                break;

            case "char":
                ok = "char".equals(tipoExpr);
                break;

            case "string":
                ok = "string".equals(tipoExpr);
                break;

            default:
                System.err.printf(
                    "\u001B[33m [ADVERTENCIA] Tipo esperado '%s' no reconocido para validación. Expresión '%s' de tipo '%s'.\u001B[0m%n",
                    tipoEsperado, valorAsignado, tipoExpr
                );
                return;
        }

        if (!ok) {
            System.err.printf(
                "\u001B[31m XXX Error semántico XXX : Valor '%s' (tipo '%s') no válido para tipo '%s'. Línea %d, columna %d.\u001B[0m%n",
                valorAsignado, tipoExpr, tipoEsperado, linea, columna
            );
            tieneErrores = true;
        }
    }

    /** @return {true} si el literal representa cero (entero o flotante simple). */
    boolean esCeroLiteral(String v) {
        return "0".equals(v) || "0.0".equals(v) || "0.".equals(v) || ".0".equals(v);
    }

    /** @return {true} si el tipo es exactamente "int". */
    boolean esEnteroTipo(String t) {
        return "int".equals(t);
    }
    
    /** @return {true} si el tipo es exactamente "float". */
    boolean esFloatTipo(String t) {
        return "float".equals(t);
    }

    /** @return {true} si ambos tipos son enteros. */
    boolean sonAmbosEnteros(String t1, String t2) {
        return esEnteroTipo(t1) && esEnteroTipo(t2);
    }


    /**
    * Regla de promoción de tipos para multiplicación.
    * @param tL tipo del operando izquierdo.
    * @param tR tipo del operando derecho.
    * @return "int" si ambos son int; "float" si hay mezcla int/float; "desconocido" en otro caso.
    */
    String tipoNumericoResultanteProducto(String tL, String tR) {
        if ("int".equals(tL) && "int".equals(tR)) return "int";
        if (( "int".equals(tL) || "float".equals(tL) ) &&
            ( "int".equals(tR) || "float".equals(tR) )) return "float";
        return "desconocido";
    }

    /**
    * @return {true} si ambos tipos son numéricos (int o float).
    */
    boolean ambosNumericos(String tL, String tR) {
        return ( "int".equals(tL) || "float".equals(tL) ) &&
            ( "int".equals(tR) || "float".equals(tR) );
    }
    // --- helpers ---

    /**
    * Hit de operador encontrado al parsear una expresión a nivel tope.
    * Contiene posición (índice en la cadena) y el lexema del operador.
    */
    static class OpHit { 
        int pos; String op; 
        OpHit(int p, String o) { pos = p; op = o; } 
    }

    /**
    * Determina si el '-' en la posición dada actúa como binario (resta) y no como unario (negación).
    * @param s cadena de la expresión.
    * @param i índice del carácter '-'.
    * @return {true} si se interpreta como binario; {false} si es unario.
    */
    boolean isBinaryMinus(String s, int i) {
        int j = i - 1;
        while (j >= 0 && Character.isWhitespace(s.charAt(j))) j--;
        if (j < 0) return false; // inicio = unario
        char L = s.charAt(j);
        return Character.isLetterOrDigit(L) || L==')' || L==']' || L=='\'' || L=='"';
    }
    
    /*
    * Busca el primer (o último) operador de un conjunto permitido al "nivel tope" (no dentro de paréntesis
    * ni dentro de literales de cadena/carácter).
    * @param s           expresión completa.
    * @param ops         lista de operadores a detectar (p.ej. {"+","-"}).
    * @param preferLast  si {true}, devuelve el último hallado; si {false}, el primero.
    * @return {OpHit} con posición y operador, o {null} si no encuentra.
    */
    OpHit findTopLevelOp(String s, String[] ops, boolean preferLast) {
        int depth = 0;
        boolean inStr = false, inChar = false;
        OpHit hit = null;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            // literales
            if (inStr) { if (c=='"'  && s.charAt(i-1)!='\\') inStr=false; continue; }
            if (inChar){ if (c=='\'' && s.charAt(i-1)!='\\') inChar=false; continue; }
            if (c=='"')  { inStr=true;  continue; }
            if (c=='\'') { inChar=true; continue; }

            //' paréntesis
            if (c=='(') { depth++; continue; }
            if (c==')') { depth--; continue; }
            if (depth!=0) continue;

            // operador de dos caracteres: //
            if (c=='/' && i+1<s.length() && s.charAt(i+1)=='/') {
                for (String op: ops) if (op.equals("\\/\\/")) {
                    OpHit h = new OpHit(i, "\\/\\/");
                    if (!preferLast) return h; else hit = h;
                }
                i++;
                continue;
            }

            // operadores de un carac
            for (String op: ops) if (op.length()==1 && c==op.charAt(0)) {
                if (op.equals("-") && !isBinaryMinus(s,i)) continue; // '-' unario, ignora
                OpHit h = new OpHit(i, op);
                if (!preferLast) return h; else hit = h;
            }
        }
        return hit;
    }

    /**
    * Elimina paréntesis exteriores que envuelven completamente la expresión (p. ej. "(1+(2*3))" -> "1+(2*3)").
    * Respeta el balanceo interno.
    * @param s expresión original.
    * @return expresión sin paréntesis exteriores redundantes.
    */
    String stripOuterParens(String s) {
        if (s==null) return null;
        s = s.trim();
        while (s.length()>=2 && s.charAt(0)=='(' && s.charAt(s.length()-1)==')') {
            int depth=0; boolean ok=true;
            for (int i=0;i<s.length();i++){
                char c=s.charAt(i);
                if (c=='(') depth++;
                else if (c==')'){ depth--; if (depth<0){ok=false;break;} }
                if (depth==0 && i<s.length()-1){ ok=false; break; }
            }
            if (!ok) break;
            s = s.substring(1,s.length()-1).trim();
        }
        return s;
    }

    /**
    * Inferencia de tipo para una expresión textual ya tokenizada/reducida.
    * Soporta literales, identificadores, suma/resta, producto/división/módulo,
    * división entera (//) y potencia (^), con respeto a precedencias mediante
    * búsqueda de operadores a nivel tope.
    * @param valor objeto cuya representación {toString()} se interpreta como expresión.
    * @return tipo inferido: "int", "float", "boolean", "string", "char" o "desconocido".
    * Reglas relevantes:
    *   {int / int -> float}
    *   {int // int -> int} (solo si ambos enteros)
    *   {int % int -> int} (solo si ambos enteros)
    *   {int * int -> int}, mixto con float -> {float}
    *   {^} devuelve {int} si ambos son int, {float} si ambos son float, {desconocido} en mezcla
    * También consulta {#buscarID(String)} si la expresión es un identificador simple.
    */
    public String obtenerTipoExpresion(Object valor) {
        if (valor == null) return "desconocido";
        String v = valor.toString().trim();
        if (v.isEmpty()) return "desconocido";
        v = stripOuterParens(v);

        if (v.matches("^-?\\d+$")) return "int";
        if (v.matches("^-?\\d*\\.\\d+$")) return "float";
        if (v.equals("true") || v.equals("false")) return "boolean";
        if (v.startsWith("\"") && v.endsWith("\"")) return "string";
        if (v.startsWith("'") && v.endsWith("'") && v.length()==3) return "char";

        OpHit hit = findTopLevelOp(v, new String[]{"+","-"}, true);
        if (hit != null) {
            String L = v.substring(0, hit.pos).trim();
            String R = v.substring(hit.pos + 1).trim();
            String tL = obtenerTipoExpresion(L);
            String tR = obtenerTipoExpresion(R);
            if (hit.op.equals("+")) {
                if (ambosNumericos(tL,tR)) return ("float".equals(tL)||"float".equals(tR)) ? "float" : "int";
                if (("string".equals(tL) && "string".equals(tR)) ||
                    ("char".equals(tL) && "char".equals(tR))) return "string";
                return "desconocido";
            } else { // '-'
                return ambosNumericos(tL,tR) ? (("float".equals(tL)||"float".equals(tR)) ? "float" : "int") : "desconocido";
            }
        }

        hit = findTopLevelOp(v, new String[]{"\\/\\/", "*", "/", "%", "^"}, false);
        if (hit != null) {
            String L, R;
            if ("\\/\\/".equals(hit.op)) {
                L = v.substring(0, hit.pos).trim();
                R = v.substring(hit.pos + 2).trim();
            } else {
                L = v.substring(0, hit.pos).trim();
                R = v.substring(hit.pos + 1).trim();
            }
            String tL = obtenerTipoExpresion(L);
            String tR = obtenerTipoExpresion(R);
            switch (hit.op) {
                case "*":
                    return tipoNumericoResultanteProducto(tL, tR);
                case "/":
                    return ambosNumericos(tL, tR) ? "float" : "desconocido";
                case "\\/\\/":
                    return ("int".equals(tL) && "int".equals(tR)) ? "int" : "desconocido";
                case "%":
                    return ("int".equals(tL) && "int".equals(tR)) ? "int" : "desconocido";
                case "^":
                    if ("int".equals(tL) && "int".equals(tR)) return "int";
                    if ("float".equals(tL) && "float".equals(tR)) return "float";
                    return "desconocido";
            }
        }

        NodoToken tok = buscarID(v);
        if (tok != null) return tok.getTipo();

        return "desconocido";
    }



/**
 * Verifica compatibilidad de tipos para operadores aritméticos/concatenación simples.
 * @param t1 tipo izquierdo.
 * @param t2 tipo derecho.
 * @return {true} si ambos tipos son iguales y pertenecen al conjunto soportado
 *         (int, float, string, char, boolean); en otro caso {false}.
 * Nota: No realiza promoción numérica; úsese junto con reglas específicas.
 */
    public boolean sonTiposCompatibles(String t1, String t2) {
        if (t1.equals("int") && t2.equals("int")) return true;
        if (t1.equals("float") && t2.equals("float")) return true;
        if (t1.equals("string") && t2.equals("string")) return true; // concatenacion
        if (t1.equals("char") && t2.equals("char")) return true;     // concatenacion de chars
        if (t1.equals("boolean") && t2.equals("boolean")) return true;

        if (t1.equals("void") && (t2 == null || t2.isEmpty())) return true;  // El retorno vacío es válido para void
        return false;
    }

    /**
    * Indica si un identificador ya existe en una tabla de símbolos dada.
    * @param currentHash hash/nombre del scope a revisar.
    * @param id          identificador a buscar.
    * @return {true} si existe una entrada con ese id; de lo contrario {false}.
    */
    public boolean esIdExistente(String currentHash, String id) {

        if (listaTablasSimbolos.containsKey(currentHash)) {
            for (NodoToken existente : listaTablasSimbolos.get(currentHash)) {
                if (existente.getId().equals(id)) {
                    return true;
                }
            }
        }
        return false;
    }


    // ==================== Manejo de errores ====================

    public boolean tieneErrores = false;

    // Para recordar última posición válida
    private int lastLine = 1;
    private int lastColumn = 1;

    /**
    * Intercepta el escáner para recordar la última posición válida (línea/columna)
    * y así poder reportar errores más precisos cuando el símbolo sea nulo.
    * @return símbolo leído por el escáner subyacente.
    * @throws Exception propagadas por el escáner.
    */
    @Override
    public Symbol scan() throws Exception {
        Symbol sym = super.scan();
        if (sym != null) {
            if (sym.left >= 0) lastLine = sym.left + 1;
            if (sym.right >= 0) lastColumn = sym.right + 1;
        }
        return sym;
    }

    // Errores recuperables

    /**
    * Manejador de errores sintácticos recuperables.
    * Marca {#tieneErrores} y reporta el token con su posición aproximada.
    * @param s símbolo problemático (puede ser nulo).
    */
    @Override
    public void syntax_error(Symbol s) {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m XXX Error sintáctico recuperable XXX :       Token '%s' en línea %d, columna %d.\u001B[0m %n", lexema, linea, columna);
    }

    // Errores no recuperables

    /**
    * Manejador de errores sintácticos no recuperables.
    * Marca {#tieneErrores} y lanza la condición tras imprimir diagnóstico.
    * @param s símbolo problemático (puede ser nulo).
    * @throws Exception para detener el parseo según la política del parser.
    */
    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m     XXX Error sintáctico crítico XXX :       Token '%s' en línea %d, columna %d. \u001B[0m %n", lexema, linea, columna);
    }
:}

action code
{:
    // Codigo de usuario - fase de analisis
    String tmp="";
:}

// TERMINALES
terminal PAR_A, PAR_C, BLO_A, BLO_C, COMA, FLECHA, FIN_E, ASIGN, COR_A, COR_C;
terminal MAS, MENOS, POR, DIV, DIV_ENT, MOD, POT;
terminal AND, OR, NOT;
terminal INC, DEC;
terminal MAYOR, MENOR, MAY_IGU, MEN_IGU, IGUAL, DIF;
terminal INT1, CHAR1, STR1, FLOAT1, BOOL1, LET, VOID, TRUE1, FALSE1, DECIDE;
terminal OF, ELSE, END, LOOP, EXIT, WHEN, FOR1, STEP, TO, DOWNTO, DO;
terminal RETURN, BREAK;
terminal INIT;

terminal ENTERO, FLOTANTE, CHAR, ID, ENTEROPO;
terminal IMPRIMIR, LEER, MAIN, CADENA;

// NO TERMINALES
non terminal Object program;
non terminal main_funcion, elemento_global, lista_global;
non terminal String tipo, tipo_funcion, tipoRes;
non terminal declaracion;
non terminal bloque, lista_sentencias, lista_sentencias_opt, sentencia, expr_opc, llamada_funcion, parametros_llamada, imprimir, leer;
non terminal funcion, parametros_opt, lista_parametros, parametro;
non terminal asignacion;
non terminal expresion, expresion_rel;
non terminal expresion_arit, termino, factor, potencia, operando;
non terminal op_rel, incrementar, decrementar;
non terminal condicional, lista_casos, caso, cond_else_opt, bucle_loop, bucle_for, step, direccion;
non terminal lista_elementos_arreglo_entero, lista_char, arreglo_char, declaracion_arreglo_entero, declaracion_arreglo_char, asignacion_arreglo, elemento_arreglo; 
non terminal declara_func, declara_main_func;

// PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left IGUAL, DIF;
precedence left MAYOR, MENOR, MAY_IGU, MEN_IGU;
precedence left MAS, MENOS;
precedence left POR, DIV, DIV_ENT, MOD;
precedence right POT;
precedence right NOT;

// PRODUCCIONES

start with program;

program ::= {:  

                inicarTS();
            :}
                lista_global main_funcion lista_global
            {:
                imprimirTablasSimbolos();
                // Guardar codigo 3d a archivo
                try {
                    java.nio.file.Files.write(
                        java.nio.file.Paths.get("intermedio.txt"),
                        codigoIntermedio.toString().getBytes()
                    );

                } catch (Exception e) {
                    System.err.println("MAL" + e.getMessage());
                }

            :}
        ;
            
lista_global ::= elemento_global lista_global
    | /* vacío */
    ;

elemento_global ::= sentencia
    | funcion
    {: :}
    ;

main_funcion ::= declara_main_func PAR_A PAR_C bloque
    {:
        currentHash = globalHash;
        cod3D("\nprincipal_end:\n\n");
    :}
    | declara_main_func bloque
    | declara_main_func error
    ;

declara_main_func ::= INIT VOID:tipo MAIN:main
                        {:
                            NodoToken func = new NodoToken();
                            func.setId(main.toString());
                            func.setTipo(tipo.toString());
                            func.setLinea(String.valueOf(lastLine));
                            func.setColumna(String.valueOf(lastColumn));
                            listaTablasSimbolos.get(globalHash).add(func);

                            currentHash = main.toString();
                            listaTablasSimbolos.put(currentHash, new ArrayList<>());

                            // CODIGO INTERMEDIO
                            cod3D("\n" + main + ":");
                        :}
                    ;

// ======== DECLARACIÓN DE VARIABLES ========
tipo ::= INT1 {: RESULT = "int"; :}
    | STR1 {: RESULT = "string"; :}
    | FLOAT1 {: RESULT = "float"; :}
    | BOOL1 {: RESULT = "boolean"; :}
    | CHAR1 {: RESULT = "char"; :}
    ;

tipoRes ::= INT1 {: RESULT = "int"; :}
    | FLOAT1 {: RESULT = "float"; :}
    | BOOL1 {: RESULT = "boolean"; :}
    | CHAR1 {: RESULT = "char"; :}
    ;

tipo_funcion ::= tipo:t {: RESULT = t; :}
    | VOID {: RESULT = "void"; :}
    ;

//+++++++++++++++++++++BLOQUE++++++++++++++++++++++++++++++++++

bloque ::= BLO_A lista_sentencias_opt BLO_C
         | BLO_A error BLO_C
         ;

lista_sentencias_opt ::= /* vacío */
                     | lista_sentencias
                     ;

lista_sentencias ::= sentencia
                  | lista_sentencias sentencia
                  ;

asignacion_arreglo::= 
    ID:nombreVar ASIGN ID:nombreArreglo BLO_A ENTEROPO:indice BLO_C
        {:
            NodoToken varToken = buscarID(nombreVar.toString());
            NodoToken arregloToken = buscarID(nombreArreglo.toString());
            var tipoVar = varToken != null ? varToken.getTipo() : "desconocido";
            var tipoArreglo = arregloToken != null ? arregloToken.getTipo() : "desconocido";
            if(varToken != null && arregloToken != null){    
                if(tipoVar.matches("int") && tipoArreglo.matches("arreglo_entero")){
                    String t1 = nuevaTempInt();
                    String t2 = nuevaTempInt();
                    String t3 = nuevaTempInt();
                    
                    cod3D(t1 + " = " + indice + " * 4"); // es 4 porque estamos guardando enteros
                    cod3D(t2 + " = base_" + nombreArreglo + " + " + t1);
                    cod3D(t3 + " = heap[" + t2 + "]");
                    cod3D(nombreVar + " = " + t3);
                } 
                else if(tipoVar.matches("char") && tipoArreglo.matches("arreglo_char")){
                    String t1 = nuevaTempInt();
                    String t2 = nuevaTempInt();
                    String t3 = nuevaTempInt();

                    cod3D(t1 + " = " + indice + " * 1"); //es uno porque lo hacemos para ascii que cada uno mide 8 bits
                    cod3D(t2 + " = base_" + nombreArreglo + " + " + t1);
                    cod3D(t3 + " = heap[" + t2 + "]");
                    cod3D(nombreVar + " = " + t3);
                }
                else {
                    System.err.printf("\u001B[31mXXX Error semántico: Tipo incompatible en asignación a arreglo. Línea %d, columna %d.\u001B[0m%n",
                        lastLine, lastColumn);
                    tieneErrores = true;
                }
            }else{
                System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' o arreglo %s no declarados. Línea %d, columna %d.\u001B[0m%n",
                    nombreVar.toString(), nombreArreglo.toString(), lastLine, lastColumn);
                tieneErrores = true;
            }
        :}
    | ID:nombreVar ASIGN BLO_A lista_elementos_arreglo_entero:elementos BLO_C
        {:
            NodoToken varToken = buscarID(nombreVar.toString());
            var tipoVar = varToken != null ? varToken.getTipo() : "desconocido";
            if(varToken != null && varToken.getTipo() == "arreglo_entero"){
                
                StringBuilder elementosStr = new StringBuilder();
                elementosStr.append("[");
                String baseTemp = "base_" + nombreVar;
                String nuevoTemporal = nuevaTempInt();
                cod3D(nuevoTemporal +" = " + baseTemp);
                if (elementos != null && elementos instanceof ArrayList) {
                    ArrayList<String> elementosLista = (ArrayList<String>) elementos;
                    for (int i = 0; i < elementosLista.size(); i++) {
                        String valor = elementosLista.get(i);
                        cod3D("heap["+nuevoTemporal+"] = " + valor);
                        cod3D(nuevoTemporal +" = "+ nuevoTemporal + " + 1");
                    }

                } else {
                    elementosStr.append("]");

                }
                
                elementosStr.append("]");
                
                varToken.setValor(elementosStr.toString());
                varToken.setLinea(String.valueOf(lastLine));
                varToken.setColumna(String.valueOf(lastColumn));
            }else{
                System.err.printf("\u001B[31mXXX Error semántico: No puedes asignar listas a variables que no lo son. Variable '%s' o arreglo %s no declarados. Línea %d, columna %d.\u001B[0m%n",
                    nombreVar.toString(), varToken.getId(), lastLine, lastColumn);
            }
        :}
    | ID:nombreVar ASIGN arreglo_char:elementos
    {:
        NodoToken varToken = buscarID(nombreVar.toString());
        var tipoVar = varToken != null ? varToken.getTipo() : "desconocido";
        if(varToken != null){
            String baseTemp = "base_" + nombreVar;
            String nuevoTemporal = nuevaTempInt();
            cod3D(nuevoTemporal+" = " + baseTemp);
            String valorStr = elementos.toString();  // viene algo como ['H','O','L','A']
            for (int i = 0; i < valorStr.length(); i++) {
                char c = valorStr.charAt(i);
                if (c == '\'' || c == '[' || c == ']' || c == ',' || c == ' ') continue; // omitir símbolos
                int ascii = (int) c;  // obtener código ASCII
                cod3D("heap["+nuevoTemporal+"] = " + ascii + "  // '" + c + "'");
                cod3D(nuevoTemporal + " = " + nuevoTemporal + " + 1");
            }//'

            varToken.setValor(elementos.toString());
            varToken.setLinea(String.valueOf(lastLine));
            varToken.setColumna(String.valueOf(lastColumn));
        }else{
            System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' no declarada. Línea %d, columna %d.\u001B[0m%n",
                nombreVar.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
    :}
    ;
elemento_arreglo ::= ID:nombreArreglo BLO_A ENTERO:tamano BLO_C 
    {:
        NodoToken arregloToken = buscarID(nombreArreglo.toString());
        if (arregloToken != null) {



            // Construimos el HashMap resultado
            HashMap<String, Object> map = new HashMap<>();
            map.put("nombre", nombreArreglo.toString());
            map.put("indice", tamano);

            String nuevoTemporal = nuevaTempInt();
            map.put("temporal", nuevoTemporal);
            cod3D(nuevoTemporal + " = base_" + nombreArreglo + " + " + tamano);
            cod3D("");

            RESULT = map;

        } else {
            System.err.printf(
                "\u001B[31mXXX Error semántico: Arreglo '%s' no declarado. Línea %d, columna %d.\u001B[0m%n",
                nombreArreglo.toString(), lastLine, lastColumn
            );
            tieneErrores = true;

            RESULT = null;
        }
    :}
;

sentencia ::= declaracion FIN_E
    | declaracion_arreglo_entero FIN_E
    | declaracion_arreglo_char FIN_E
    | asignacion_arreglo FIN_E
    | asignacion FIN_E
    | llamada_funcion FIN_E
    | imprimir FIN_E
    | leer FIN_E
    | RETURN expr_opc:e FIN_E
            {:
                String tipoRetorno = obtenerTipoDeFuncionActual();
                if (e == null) {
                    if (!"void".equals(tipoRetorno)) {
                        System.err.printf(
                            "\u001B[31mXXX Error semántico XXX : La función requiere retornar '%s' pero no se retornó valor. Línea %d, columna %d.\u001B[0m%n",
                            tipoRetorno, lastLine-1, lastColumn
                        );
                        tieneErrores = true;
                    } else {
                        cod3D("call return(), 1");
                    }
                } else {
                    if ("void".equals(tipoRetorno)) {
                        System.err.printf(
                            "\u001B[31mXXX Error semántico XXX : Una función 'void' no debe retornar un valor. Línea %d, columna %d.\u001B[0m%n",
                            lastLine-1, lastColumn
                        );
                        tieneErrores = true;
                    } else {
                        String valorReal, tempValor;
                        if (e instanceof java.util.HashMap) {
                            valorReal = ((HashMap)e).get("valor").toString();
                            tempValor = ((HashMap)e).get("temp").toString();
                        } else {
                            valorReal = e.toString();
                            tempValor = valorReal;
                        }

                        String tipoExpr = obtenerTipoExpresion(valorReal);

                        if (!sonTiposCompatibles(tipoRetorno, tipoExpr)) {
                            System.err.printf(
                                "\u001B[31mXXX Error semántico XXX : Tipo de expresión en RETURN no coincide con el tipo de retorno. Se esperaba '%s' y se obtuvo '%s'. Línea %d, columna %d.\u001B[0m%n",
                                tipoRetorno, tipoExpr, lastLine-1, lastColumn
                            );
                            tieneErrores = true;
                        }
                        if(tipoRetorno == "string"){
                            System.out.printf("\u001B[31mXXX Error semántico XXX : No puedes crear funciones que retornen tipo string. Línea %d, columna %d.\u001B[0m%n",
                            lastLine-1, lastColumn);
                            tieneErrores = true;
                        } else {
                            cod3D("param " + tempValor);
                            cod3D("call return()");
                        }
                    }
                }
            :}
    | BREAK FIN_E
    | incrementar FIN_E
    | decrementar FIN_E
    | condicional FIN_E
    | bucle_loop 
    | bucle_for
    | error FIN_E
    | elemento_arreglo FIN_E
    ;

incrementar ::= ID INC;
decrementar ::= ID DEC;

expr_opc ::=
      expresion:e
        {: RESULT = e; :}
    | /* ε */
        {: RESULT = null; :}
    ;

llamada_funcion ::= ID:nombreFunc PAR_A parametros_llamada:parametros PAR_C
                    {:


                        NodoToken funcToken = buscarID(nombreFunc.toString());
                        if (funcToken == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : Función '%s' no declarada. Línea %d, columna %d.\u001B[0m%n",
                                nombreFunc.toString(), lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            java.util.List<String> definidos = funcToken.getParametros();

                            java.util.List<HashMap<String,String>> listaParams;
                            if (parametros instanceof java.util.List) {
                                listaParams = (java.util.List<HashMap<String,String>>) parametros;
                            } else {
                                listaParams = new java.util.ArrayList<HashMap<String,String>>();
                            }

                            java.util.List<String> llamados = new java.util.ArrayList<String>();
                            for (HashMap<String,String> pInfo : listaParams) {
                                String v = pInfo.get("valor");
                                if (v != null) {
                                    llamados.add(v);
                                }
                            }

                            if (definidos.size() != llamados.size()) {
                                System.err.printf("\u001B[31mXXX Error semántico XXX : La función '%s' esperaba %d parámetros, pero se enviaron %d. Línea %d, columna %d.\u001B[0m%n",
                                    nombreFunc, definidos.size(), llamados.size(), lastLine, lastColumn);
                                tieneErrores = true;
                            } else {
                                for (int i = 0; i < definidos.size(); i++) {
                                    String paramDef = definidos.get(i);
                                    NodoToken declParam = null;

                                    String funcScope = nombreFunc.toString();
                                    if (listaTablasSimbolos.containsKey(funcScope)) {
                                        for (NodoToken t : listaTablasSimbolos.get(funcScope)) {
                                            if (t.getId().equals(paramDef)) {
                                                declParam = t;
                                                break;
                                            }
                                        }
                                    }

                                    String paramLlamado = llamados.get(i);
                                    String tipoEnviado = obtenerTipoExpresion(paramLlamado);
                                    String tipoEsperado = (declParam != null) ? declParam.getTipo() : "desconocido";

                                    if (!sonTiposCompatibles(tipoEsperado, tipoEnviado)) {
                                        System.err.printf("\u001B[31mXXX Error semántico XXX : En parámetro #%d de función '%s', se esperaba tipo '%s' pero se envió '%s'. Línea %d, columna %d.\u001B[0m%n",
                                            i + 1, nombreFunc, tipoEsperado, tipoEnviado, lastLine, lastColumn);
                                        tieneErrores = true;
                                    }
                                }

                                for (HashMap<String,String> pInfo : listaParams) {
                                    String tempValor = pInfo.get("temp");
                                    if (tempValor == null || tempValor.equals("error")) {
                                        System.err.printf("\u001B[31mXXX Error semántico XXX : Parámetro con temporal inválido en llamada a '%s'. Línea %d, columna %d.\u001B[0m%n",
                                            nombreFunc.toString(), lastLine, lastColumn);
                                        tieneErrores = true;
                                    } else {
                                        cod3D("param " + tempValor);
                                    }
                                }

                                String funcTemp = nuevaTempInt();
                                String tipoRetorno = funcToken.getTipo();

                                if (!"void".equals(tipoRetorno)) {
                                    cod3D(funcTemp + " = call " + nombreFunc + "(), " + definidos.size());
                                    

                                    NodoToken tempRet = new NodoToken();
                                    tempRet.setId(funcTemp);
                                    tempRet.setTipo(tipoRetorno);
                                    tempRet.setValor("retorno_" + nombreFunc);
                                    tempRet.setLinea(String.valueOf(lastLine));
                                    tempRet.setColumna(String.valueOf(lastColumn));

                                    tempRet.setParametros(
                                        new java.util.ArrayList<String>(funcToken.getParametros())
                                    );

                                    listaTablasSimbolos.get(currentHash).add(tempRet);



                                    RESULT = funcTemp;
                                } else {
                                    cod3D("call " + nombreFunc + "(), " + definidos.size());

                                    RESULT = null;
                                }
                            }
                        }
                    :}
                ;


parametros_llamada ::= expresion:e
                {:
                    java.util.List<HashMap<String,String>> lista = new java.util.ArrayList<>();

                    String valorReal;
                    String tempValor;

                    if (e instanceof java.util.HashMap) {
                        valorReal = ((HashMap)e).get("valor").toString();
                        tempValor = ((HashMap)e).get("temp").toString();
                    } else {
                        valorReal = e.toString();
                        tempValor = valorReal;
                    }

                    HashMap<String,String> paramInfo = new HashMap<>();
                    paramInfo.put("valor", valorReal);
                    paramInfo.put("temp",  tempValor);

                    lista.add(paramInfo);
                    RESULT = lista;
                :}
            | expresion:e COMA parametros_llamada:pl
                {:
                    java.util.List<HashMap<String,String>> lista;

                    if (pl instanceof java.util.List) {
                        lista = (java.util.List<HashMap<String,String>>) pl;
                    } else {
                        lista = new java.util.ArrayList<>();
                    }

                    String valorReal;
                    String tempValor;

                    if (e instanceof java.util.HashMap) {
                        valorReal = ((HashMap)e).get("valor").toString();
                        tempValor = ((HashMap)e).get("temp").toString();
                    } else {
                        valorReal = e.toString();
                        tempValor = valorReal;
                    }

                    HashMap<String,String> paramInfo = new HashMap<>();
                    paramInfo.put("valor", valorReal);
                    paramInfo.put("temp",  tempValor);

                    lista.add(0, paramInfo);
                    RESULT = lista;
                :}
            | /* vacío */
                {:
                    RESULT = new java.util.ArrayList<HashMap<String,String>>();
                :}
            ;


imprimir ::= IMPRIMIR PAR_A expresion:e PAR_C
                {:
                    String valorReal = "";
                    String tempValor = "";

                    if (e != null) {
                        if (e instanceof java.util.HashMap) {
                            valorReal = ((HashMap)e).get("valor").toString();
                            tempValor = ((HashMap)e).get("temp").toString();
                        } else {
                            valorReal = e.toString();
                            tempValor = valorReal;
                        }

                        String tipoExpr = obtenerTipoExpresion(valorReal);
                        if(tipoExpr == "boolean"){
                            System.err.printf("\u001B[31mXXX Error semántico: No se puede imprimir una expresión de tipo 'bool'. Línea %d, columna %d.\u001B[0m%n",
                                lastLine, lastColumn);
                            tieneErrores = true;
                        } else if (tipoExpr == "char") {
                            System.err.printf("\u001B[31mXXX Error semántico: No se puede imprimir una expresión de tipo 'char'. Línea %d, columna %d.\u001B[0m%n",
                                lastLine, lastColumn);
                            tieneErrores = true;
                        } else if ("void".equals(tipoExpr)) {
                            System.err.printf("\u001B[31mXXX Error semántico: No se puede imprimir una expresión de tipo 'void'. Línea %d, columna %d.\u001B[0m%n",
                                lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            if (valorReal != "error") {
                                cod3D("param " + tempValor);

                                if (tipoExpr == "string") {
                                    cod3D("call printStr(), 1");
                                } else if (tipoExpr == "int") {
                                    cod3D("call printInt(), 1");
                                } else if (tipoExpr == "float") {
                                    cod3D("call printFloat(), 1");
                                }

                                NodoToken imp = new NodoToken();
                                imp.setTipo("llamada_funcion_sistema");
                                imp.setId("imprimir");
                                imp.setValor(valorReal);
                                imp.setLinea(String.valueOf(lastLine));
                                imp.setColumna(String.valueOf(lastColumn));
                                listaTablasSimbolos.get(currentHash).add(imp);

                            }
                        }
                    } else {
                        System.err.printf("\u001B[31mXXX Error semántico: llamada a output() sin expresión válida. Línea %d, columna %d.\u001B[0m%n",
                            lastLine, lastColumn);
                        tieneErrores = true;
                    }

                    RESULT = null;
                :}
            | IMPRIMIR PAR_A error PAR_C
            ;


leer ::= LEER PAR_A ID:var PAR_C
        {:
            NodoToken varTok = buscarID(var.toString());
            if (varTok == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no ha sido declarada antes de leer(). Línea %d, columna %d.\u001B[0m%n",
                    var.toString(), lastLine, lastColumn);
                tieneErrores = true;
            }
            else {
                String tipo = varTok.getTipo();
                if(tipo == "char"){
                    System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' es de tipo char y no se puede usar con leer(). Línea %d, columna %d.\u001B[0m%n",
                        var.toString(), lastLine, lastColumn);
                    tieneErrores = true;
                }else{

                    String temp;

                    if (tipo == "float") {
                        temp = nuevaTempFloat();
                        cod3D(temp + " = call readFloat(), 1");
                    } else if (tipo == "string") {
                        temp = nuevaTempInt();
                        cod3D(temp + " = call readString(), 1");
                    } else if (tipo == "int") {
                        temp = nuevaTempInt();
                        cod3D(temp + " = call readInt(), 1");
                    } else {
                        temp = nuevaTempInt();
                        cod3D(temp + " = call readInt(), 1"); // por defecto int
                    }
                    cod3D(var + " = " + temp);

                    NodoToken leerNode = new NodoToken();
                    leerNode.setTipo("llamada_funcion_sistema");
                    leerNode.setId("leer");
                    leerNode.setValor("asigna_a:" + var.toString());
                    leerNode.setLinea(String.valueOf(lastLine));
                    leerNode.setColumna(String.valueOf(lastColumn));
                    listaTablasSimbolos.get(currentHash).add(leerNode);


                }
            }

            RESULT = null;
        :}
        ;


//+++++++++++++++++++++FUNCIONES++++++++++++++++++++++++++++++++

funcion ::= declara_func:nombreFun PAR_A lista_parametros:params PAR_C 
                {:

                    NodoToken func = buscarID(nombreFun.toString());

                    cod3D("\n" + nombreFun + ":");
                    int count = 0;
                    if (params != null && !params.toString().isEmpty()) {
                        String[] lista = params.toString().split(",");
                        for (String p : lista) {
                            p = p.trim();
                            if (!p.isEmpty()) {
                                func.addParametro(p);

                                NodoToken paramTok = new NodoToken();
                                paramTok.setId(p);
                                paramTok.setTipo("desconocido"); 
                                paramTok.setLinea(String.valueOf(lastLine));
                                paramTok.setColumna(String.valueOf(lastColumn));

                                if (!listaTablasSimbolos.containsKey("TS_FUNC_" + nombreFun.toString()))
                                    listaTablasSimbolos.put("TS_FUNC_" + nombreFun.toString(), new ArrayList<>());
                                listaTablasSimbolos.get("TS_FUNC_" + nombreFun.toString()).add(paramTok);

                                // código intermedio
                                String temp = nuevaTempInt();
                                cod3D(p + " = " + "param[" + count + "]");
                                count++;


                            }
                        }
                    }

                :}
        bloque
                {:
                    currentHash = globalHash;
                    cod3D("\n" + nombreFun + "_end:");
                :}
        | declara_func PAR_A parametros_opt PAR_C error
        | declara_func PAR_A error PAR_C bloque
        ;

lista_parametros ::= parametro:p
                        {:
                            RESULT = p;

                        :}
                    | parametro:p COMA lista_parametros:l
                        {:
                            RESULT = p + "," + l;

                        :}
                    | /* vacío */
                        {:
                            RESULT = "";
                        :}
                    ;

declara_func ::= tipo_funcion:tipoFun ID:nombreFun 
                {:
                    NodoToken func = new NodoToken();
                    func.setId(nombreFun.toString());
                    func.setTipo(tipoFun.toString());
                    func.setLinea(String.valueOf(lastLine));
                    func.setColumna(String.valueOf(lastColumn));
                    listaTablasSimbolos.get(globalHash).add(func);

                    currentHash = nombreFun.toString();
                    if (!listaTablasSimbolos.containsKey(currentHash))
                        listaTablasSimbolos.put(currentHash, new ArrayList<>());

                    RESULT = nombreFun.toString();
                :}
            ;

parametro ::= tipo:ti ID:nombreParam
    {:
        if (esIdExistente(currentHash, nombreParam.toString())) {
            System.err.printf("\u001B[31mXXX Error semántico: Parámetro '%s' ya declarado en función. Línea %d, columna %d.\u001B[0m%n",
                nombreParam.toString(), lastLine, lastColumn);
            tieneErrores = true;
        } else {
            NodoToken param = new NodoToken();
            param.setTipo(ti);
            param.setId(nombreParam.toString());
            param.setLinea(String.valueOf(lastLine)); 
            param.setColumna(String.valueOf(lastColumn));

            // 🔹 Marca el parámetro como "ya tiene valor" (aunque no conozcas cuál)
            // con esto tus chequeos de getValor() != null dejan de reventar
            switch (ti) {
                case "int":
                    param.setValor("0");      // placeholder, no se usa en las expresiones
                    break;
                case "float":
                    param.setValor("0.0");
                    break;
                case "boolean":
                    param.setValor("true");   // o "false", da igual, solo importa que no sea null
                    break;
                case "char":
                    param.setValor("'\\0'");
                    break;
                case "string":
                    param.setValor("\"\"");   // string vacío
                    break;
                default:
                    param.setValor("param");  // fallback
            }

            listaTablasSimbolos.get(currentHash).add(param);

            // No necesitas temp aquí para semántica; lo importante es RESULT
            RESULT = nombreParam.toString();
        }
    :}
    ;


//+++++++++++++++++++++DECLARACIONES Y ASIGNACIONES+++++++++++++++

// VERSIÓN SIMPLIFICADA - DECLARACIONES SEPARADAS
declaracion ::= LET tipo:tipoDato ID:nombreDeclaracion 
                    {:

                        if (esIdExistente(currentHash, nombreDeclaracion.toString())) {
                            System.err.printf(" \u001B[31mXXX Error semántico: Variable '%s' ya declarada en scope actual. Línea %d, columna %d.\u001B[0m%n",
                                nombreDeclaracion.toString(), lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            NodoToken declaracion = new NodoToken();
                            declaracion.setTipo(tipoDato);
                            declaracion.setId(nombreDeclaracion.toString());
                            declaracion.setLinea(String.valueOf(lastLine));
                            declaracion.setColumna(String.valueOf(lastColumn));

                            // ====== RESERVA DE MEMORIA EN COD3D ======
                            String tempDefault = null;

                            switch (tipoDato) {
                                case "int":
                                    tempDefault = nuevaTempInt();
                                    cod3D(tempDefault + " = 0");
                                    cod3D(nombreDeclaracion + " = " + tempDefault);
                                    declaracion.setValor("0");
                                    break;

                                case "float":
                                    tempDefault = nuevaTempFloat();
                                    cod3D(tempDefault + " = 0.0");
                                    cod3D(nombreDeclaracion + " = " + tempDefault);
                                    declaracion.setValor("0.0");
                                    break;

                                case "boolean":
                                    tempDefault = nuevaTempInt();
                                    cod3D(tempDefault + " = false");        // false
                                    cod3D(nombreDeclaracion + " = " + tempDefault);
                                    declaracion.setValor("false");
                                    break;

                                case "char":
                                    tempDefault = nuevaTempInt();
                                    cod3D(tempDefault + " = '\\0'");    // char nulo
                                    cod3D(nombreDeclaracion + " = " + tempDefault);
                                    declaracion.setValor("'\\0'");
                                    break;

                                case "string":
                                    tempDefault = nuevaTempInt();
                                    cod3D(tempDefault + " = \"\"");     // string vacío
                                    cod3D(nombreDeclaracion + " = " + tempDefault);
                                    declaracion.setValor("\"\"");
                                    break;

                                default:
                                    declaracion.setValor(null);
                                    break;
                            }

                            listaTablasSimbolos.get(currentHash).add(declaracion);

                        }
                    :}
                | LET tipo:tipoDato ID:nombreDeclaracion ASIGN expresion:valorExpr
                    {:
                        if (esIdExistente(currentHash, nombreDeclaracion.toString())) {
                            System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' ya declarada en ámbito actual. Línea %d, columna %d.\u001B[0m%n",
                                nombreDeclaracion.toString(), lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            // Declaración CON asignación
                            NodoToken declaracion = new NodoToken();
                            declaracion.setTipo(tipoDato);
                            declaracion.setId(nombreDeclaracion.toString());

                            if (valorExpr != null) {
                                String valorReal = "";
                                String tempValor = "";
                                if (valorExpr instanceof java.util.HashMap) {
                                    valorReal = ((HashMap)valorExpr).get("valor").toString();
                                    tempValor = ((HashMap)valorExpr).get("temp").toString();
                                } else {
                                    valorReal = valorExpr.toString();
                                    tempValor = valorReal;
                                }

                                validarAsignacionTipo(tipoDato, valorReal, lastLine, lastColumn);
                                if (!(valorReal == "error" || tempValor == "error")) {
                                    declaracion.setValor(valorReal);

                                    cod3D(nombreDeclaracion + " = " + tempValor);


                                }
                            } else {
                                declaracion.setValor(null);

                            }

                            declaracion.setLinea(String.valueOf(lastLine));
                            declaracion.setColumna(String.valueOf(lastColumn));
                            listaTablasSimbolos.get(currentHash).add(declaracion);
                        }
                    :}
                | LET tipo ID ASIGN error 
                ;


declaracion_arreglo_entero ::= LET tipo:tip ID:nombreArreglo BLO_A expresion:tam BLO_C ASIGN BLO_A lista_elementos_arreglo_entero:elementos BLO_C
                                {:
                                    if(buscarID(nombreArreglo.toString()) == null && tip == "int"){

                                        // Declaración de arreglo de enteros CON asignación
                                        NodoToken declaracion = new NodoToken();
                                        declaracion.setTipo("arreglo_entero");
                                        declaracion.setId(nombreArreglo.toString());
                                        
                                        String baseTemp = "base_" + nombreArreglo;
                                        cod3D(baseTemp + " = HP"); // base del arreglo

                                        StringBuilder elementosStr = new StringBuilder();
                                        elementosStr.append("[");
                                        
                                        if (elementos != null && elementos instanceof ArrayList) {
                                            ArrayList<String> elementosLista = (ArrayList<String>) elementos;
                                            for (int i = 0; i < elementosLista.size(); i++) {
                                                if (i > 0) elementosStr.append(", ");
                                                elementosStr.append(elementosLista.get(i));
                                                cod3D("heap[HP] = " + elementosLista.get(i).toString());
                                                cod3D("HP = HP + 1");
                                            }
                                            
                                        } else {
                                            elementosStr.append("]");

                                        }
                                        
                                        elementosStr.append("]");
                                        
                                        declaracion.setValor(elementosStr.toString());
                                        declaracion.setLinea(String.valueOf(lastLine));
                                        declaracion.setColumna(String.valueOf(lastColumn));
                                        listaTablasSimbolos.get(currentHash).add(declaracion);
                    
                                    }
                                :}
                                | LET tipo:tipo ID:nombreArreglo BLO_A expresion:tam BLO_C {:
                                    
                                    if(buscarID(nombreArreglo.toString()) == null){
                                        if (tipo == "char") {
                                            
                                            NodoToken declaracion = new NodoToken();
                                            String baseTemp = "base_" + nombreArreglo;
                                            cod3D(baseTemp + " = HP");
                                            HashMap<String, String> info = (HashMap<String, String>) tam;
                                            // convertir el tamaño a entero si viene como expresión
                                            String tamStr = info.get("valor").toString();
                                            cod3D("HP = HP + " + tamStr);  // reservar espacio vacío
                                            declaracion.setTipo("arreglo_char");
                                            declaracion.setId(nombreArreglo.toString());
                                            declaracion.setValor(""); // Valor por defecto
                                            declaracion.setLinea(String.valueOf(lastLine));
                                            declaracion.setColumna(String.valueOf(lastColumn));
                                            listaTablasSimbolos.get(currentHash).add(declaracion);
                                            
                                        }else if(tipo == "int"){

                                            NodoToken declaracion = new NodoToken();
                                            String baseTemp = "base_" + nombreArreglo;
                                            cod3D(baseTemp + " = HP");
                                            HashMap<String, String> info = (HashMap<String, String>) tam;
                                            // convertir el tamaño a entero si viene como expresión
                                            String tamStr = info.get("valor").toString();
                                            cod3D("HP = HP + " + tamStr);  // reservar espacio vacío
                                            declaracion.setTipo("arreglo_entero");
                                            declaracion.setId(nombreArreglo.toString());
                                            declaracion.setValor(""); // Valor por defecto
                                            declaracion.setLinea(String.valueOf(lastLine));
                                            declaracion.setColumna(String.valueOf(lastColumn));
                                            listaTablasSimbolos.get(currentHash).add(declaracion);
                                        }
                                        else{
                                            System.err.printf("\u001B[31mXXX Error semántico: Tipo '%s' no válido para arreglo de enteros. Línea %d, columna %d.\u001B[0m%n",
                                                tipo.toString(), lastLine, lastColumn);
                                            tieneErrores = true;
                                        }
                                    }else{
                                        System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' ya declarada en ámbito actual o tipo incorrecto. Línea %d, columna %d.\u001B[0m%n",
                                            nombreArreglo.toString(), lastLine, lastColumn);
                                        tieneErrores = true;
                                    }
                                :}
                            ;

declaracion_arreglo_char ::= LET tipo:tip ID:nombreArregloChar BLO_A expresion BLO_C ASIGN arreglo_char:valoresChar
                                {:
                                    if(buscarID(nombreArregloChar.toString()) == null && tip == "char"){
                                        // Declaración de arreglo de chars CON asignación
                                        NodoToken declaracion = new NodoToken();
                                        declaracion.setTipo("arreglo_char");
                                        declaracion.setId(nombreArregloChar.toString());
                                        
                                        if (valoresChar != null) {
                                            String valorStr = valoresChar.toString();
                                            String baseTemp = "base_" + nombreArregloChar;
                                            cod3D(baseTemp + " = HP");
                                            for (int i = 0; i < valorStr.length(); i++) {
                                                char c = valorStr.charAt(i);
                                                if (c == '\'' || c == '[' || c == ']' || c == ',' || c == ' ') continue;
                                                int ascii = (int) c;
                                                cod3D("heap[HP] = " + ascii);
                                                cod3D("HP = HP + 1");
                                            }//'
                                            declaracion.setValor(valorStr);
                                            
                                        } else {
                                            declaracion.setValor("arreglo_char");

                                        }
                                        declaracion.setLinea(String.valueOf(lastLine));
                                        declaracion.setColumna(String.valueOf(lastColumn));
                                        listaTablasSimbolos.get(currentHash).add(declaracion);
                                    }else{

                                        tieneErrores = true;
                                    }
                                :}
                            ;

lista_char ::= CHAR:caracter 
                {: 
                    RESULT = caracter.toString();
                :}
            | lista_char:lista COMA CHAR:caracter 
                {: 
                    String listaStr = lista.toString() + ", " + caracter.toString();
                    RESULT = listaStr;
                :}
            ;

arreglo_char ::= BLO_A lista_char:lista BLO_C 
                    {: 
                        String resultado = "[" + lista.toString() + "]";
                        RESULT = resultado;
                    :}
                ;

asignacion ::= ID:nombre ASIGN expresion:valor
                    {:
                        NodoToken variable = buscarID(nombre.toString());
                        if (variable != null) {
                            if (valor != null) {
                                String valorReal = "";
                                String tempValor = "";
                                if (valor instanceof java.util.HashMap) {
                                    valorReal = ((HashMap)valor).get("valor").toString();
                                    tempValor = ((HashMap)valor).get("temp").toString();
                                } else {
                                    valorReal = valor.toString();
                                    tempValor = valorReal;
                                }

                                validarAsignacionTipo(variable.getTipo(), valorReal, lastLine, lastColumn);

                                if (!(valorReal == "error" || tempValor == "error")) {
                                    cod3D(nombre + " = " + tempValor);
                                    variable.setValor(valorReal);

                                    
                                }
                            } else {
                                variable.setValor(null);
                            }
                        } else {
                            System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
                                nombre.toString(), lastLine, lastColumn);
                            tieneErrores = true;
                        }
                        RESULT = nombre;
                    :}
            | ID:nombre COR_A ENTERO COR_C ASIGN ENTERO:valorArr
                {:
                    NodoToken variable = buscarID(nombre.toString());
                    if (variable != null) {
                        variable.setValor("arreglo_entero[" + valorArr + "]");
                        cod3D(nombre + "[" + valorArr + "] = " + valorArr);
                    } else {
                        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
                            nombre.toString(), lastLine, lastColumn);
                        tieneErrores = true;
                    }
                        RESULT = nombre;
                :}
            | ID:nombre COR_A ENTERO COR_C ASIGN CHAR:valorChar
                {:
                    NodoToken variable = buscarID(nombre.toString());
                    if (variable != null) {
                        variable.setValor("arreglo_char");
                        cod3D(nombre + "[" + valorChar + "] = arreglo_char");
                    } else {
                        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
                            nombre.toString(), lastLine, lastColumn);
                        tieneErrores = true;
                    }
                    RESULT = nombre;
                :}
            ;


// EXPRESIONES
expresion ::=
      expresion:e1 AND expresion:e2
        {:
            HashMap<String, String> res = new HashMap<>();

            if (e1 != null && e2 != null && !((HashMap)e2).isEmpty()) {
                String temp1 = ((HashMap)e1).get("temp").toString();
                String temp2 = ((HashMap)e2).get("temp").toString();
                String temp  = genOperacion3D(temp1, "&&", temp2);
                res.put("temp",  temp);
                res.put("valor", "true");
            } else {
                System.err.printf("\u001B[31mXXX Error semántico XXX : Operandos nulos o vacíos en la expresión AND. Línea %d, columna %d.\u001B[0m%n",
                    lastLine, lastColumn);
                tieneErrores = true;
                res.put("temp",  "error");
                res.put("valor", "error");
            }

            RESULT = res;
        :}
    | expresion:e1 OR expresion:e2
        {:
            HashMap<String, String> res = new HashMap<>();

            if (e1 != null && e2 != null && !((HashMap)e2).isEmpty()) {
                String temp1 = ((HashMap)e1).get("temp").toString();
                String temp2 = ((HashMap)e2).get("temp").toString();
                String temp  = genOperacion3D(temp1, "||", temp2);
                res.put("temp",  temp);
                res.put("valor", "true");
            } else {
                System.err.printf("\u001B[31mXXX Error semántico XXX : Operandos nulos o vacíos en la expresión OR. Línea %d, columna %d.\u001B[0m%n",
                    lastLine, lastColumn);
                tieneErrores = true;
                res.put("temp",  "error");
                res.put("valor", "error");
            }

            RESULT = res;
        :}
    | expresion_rel:e
        {:
            RESULT = e;
        :}
    ;

expresion_rel ::=
      NOT expresion_rel:e
        {:
            HashMap<String,String> res = new HashMap<>();
            String opTemp  = "";
            String opValor = "";

            if (e == null) {
                System.err.println(">>> [ERROR] Expresión nula en operador NOT (línea " + lastLine + ")");
                opTemp  = "error";
                opValor = "error";
            } else if (e instanceof java.util.HashMap) {
                HashMap tmp = (HashMap)e;
                opTemp  = tmp.get("temp")  != null ? tmp.get("temp").toString()  : "error";
                opValor = tmp.get("valor") != null ? tmp.get("valor").toString() : "true";
            } else {
                opTemp  = e.toString();
                opValor = e.toString();
            }

            String temp = nuevaTempInt();
            cod3D(temp + " = !" + opTemp);
            res.put("temp",  temp);
            res.put("valor", "!" + opValor);

            RESULT = res;
        :}
    | expresion_arit:e1 op_rel:op expresion_arit:e2
        {:
            HashMap<String, String> res = new HashMap<>();

            if (e1 != null && e2 != null) {
                String val1 = ((HashMap)e1).get("valor").toString();
                String val2 = ((HashMap)e2).get("valor").toString();
                String tipo1 = obtenerTipoExpresion(val1);
                String tipo2 = obtenerTipoExpresion(val2);

                if (sonTiposCompatibles(tipo1, tipo2)) { 
                    String t1 = ((HashMap)e1).get("temp").toString();
                    String t2 = ((HashMap)e2).get("temp").toString();
                    String temp = genOperacion3D(t1, op.toString(), t2);
                    res.put("temp",  temp);
                    res.put("valor", "true");
                    RESULT = res;
                } else {
                    System.err.printf(
                        "\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en expresión relacional. Línea %d, columna %d.\u001B[0m%n",
                        tipo1, tipo2, lastLine, lastColumn
                    );
                    tieneErrores = true;
                    RESULT = null;
                }
            } else {
                System.err.printf(
                    "\u001B[31mXXX Error semántico XXX : Expresiones nulas en operación relacional. Línea %d, columna %d.\u001B[0m%n",
                    lastLine, lastColumn
                );
                tieneErrores = true;
                RESULT = null;
            }
        :}
    | expresion_arit:e
        {:
            RESULT = e;
        :}
    ;


// EXPRESIONES ARITMETICAS
expresion_arit ::= expresion_arit:e1 MAS termino:e2
                    {:
                        HashMap<String,String> res = new HashMap<>();
                        String v1 = ((HashMap)e1).get("valor").toString();
                        String v2 = ((HashMap)e2).get("valor").toString();
                        String t1 = ((HashMap)e1).get("temp").toString();
                        String t2 = ((HashMap)e2).get("temp").toString();

                        if (sonTiposCompatibles(obtenerTipoExpresion(v1), obtenerTipoExpresion(v2))) {
           
                            NodoToken var1 = buscarID(v1);
                            NodoToken var2 = buscarID(v2);

                            if (var1 != null && var1.getValor() == null) {
                                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                                tieneErrores = true;
                            } else if (var2 != null && var2.getValor() == null) {
                                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                                tieneErrores = true;
                            } else {

                                String temp = genOperacion3D(t1, "+", t2);
                                res.put("temp", temp);
                                res.put("valor", v1+"+"+v2);
                            }
                        } else {
                            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en suma. Línea %d, columna %d.\u001B[0m%n",
                                obtenerTipoExpresion(v1), obtenerTipoExpresion(v2), lastLine, lastColumn);
                            tieneErrores = true;
                            res.put("temp","error");
                            res.put("valor","error");
                        }

                        RESULT = res;
                    :}
                | expresion_arit:e1 MENOS termino:e2
                    {:
                        HashMap<String,String> res = new HashMap<>();
                        String v1 = ((HashMap)e1).get("valor").toString();
                        String v2 = ((HashMap)e2).get("valor").toString();
                        String t1 = ((HashMap)e1).get("temp").toString();
                        String t2 = ((HashMap)e2).get("temp").toString();

                        if (sonTiposCompatibles(obtenerTipoExpresion(v1), obtenerTipoExpresion(v2))) {

                            NodoToken var1 = buscarID(v1);
                            NodoToken var2 = buscarID(v2);

                            if (var1 != null && var1.getValor() == null) {
                                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                                tieneErrores = true;
                            } else if (var2 != null && var2.getValor() == null) {
                                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                                tieneErrores = true;
                            } else {

                                String temp = genOperacion3D(t1, "-", t2);
                                res.put("temp", temp);
                                res.put("valor", v1+"-"+v2);
                            }
                        } else {
                            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en resta. Línea %d, columna %d.\u001B[0m%n",
                                obtenerTipoExpresion(v1), obtenerTipoExpresion(v2), lastLine, lastColumn);
                            tieneErrores = true;
                            res.put("temp","error");
                            res.put("valor","error");
                        }
                        RESULT = res;
                    :}
                | termino:t {: RESULT = t; :}
                ;

// TERMINOS
termino ::= termino:e1 POR factor:e2
                {:
                    HashMap<String,String> res = new HashMap<>();
                    String v1 = ((HashMap)e1).get("valor").toString();
                    String v2 = ((HashMap)e2).get("valor").toString();
                    String t1 = ((HashMap)e1).get("temp").toString();
                    String t2 = ((HashMap)e2).get("temp").toString();

                    String tt1 = obtenerTipoExpresion(v1);
                    String tt2 = obtenerTipoExpresion(v2);

                    if (!sonTiposCompatibles(tt1, tt2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en multiplicación. Línea %d, columna %d.\u001B[0m%n",
                            tt1, tt2, lastLine, lastColumn);
                    } else {

                        NodoToken var1 = buscarID(v1);
                        NodoToken var2 = buscarID(v2);

                        if (var1 != null && var1.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                            tieneErrores = true;
                        } else if (var2 != null && var2.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            String temp = genOperacion3D(t1, "*", t2);
                            res.put("temp", temp);
                            res.put("valor", v1 + "*" + v2);
                        }
                    }
                    RESULT = res;
                :}
        | termino:e1 DIV factor:e2
                {:
                    HashMap<String,String> res = new HashMap<>();
                    String v1 = ((HashMap)e1).get("valor").toString();
                    String v2 = ((HashMap)e2).get("valor").toString();
                    String t1 = ((HashMap)e1).get("temp").toString();
                    String t2 = ((HashMap)e2).get("temp").toString();

                    String tt1 = obtenerTipoExpresion(v1);
                    String tt2 = obtenerTipoExpresion(v2);

                    if (!sonTiposCompatibles(tt1, tt2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en división. Línea %d, columna %d.\u001B[0m%n",
                            tt1, tt2, lastLine, lastColumn);
                    }
                    else if (esCeroLiteral(v2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: División por cero (literal 0/0.0). Línea %d, columna %d.\u001B[0m%n",
                            lastLine, lastColumn);
                    } else {
                        NodoToken var1 = buscarID(v1);
                        NodoToken var2 = buscarID(v2);

                        if (var1 != null && var1.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                            tieneErrores = true;
                        } else if (var2 != null && var2.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            String temp = genOperacion3D(t1, "/", t2);
                            res.put("temp", temp);
                            res.put("valor", v1 + "/" + v2);
                        }
                    }
                    RESULT = res;
                :}
        | termino:e1 DIV_ENT factor:e2
                {:
                    HashMap<String,String> res = new HashMap<>();
                    String v1 = ((HashMap)e1).get("valor").toString();
                    String v2 = ((HashMap)e2).get("valor").toString();
                    String t1 = ((HashMap)e1).get("temp").toString();
                    String t2 = ((HashMap)e2).get("temp").toString();

                    String tt1 = obtenerTipoExpresion(v1);
                    String tt2 = obtenerTipoExpresion(v2);

                    if (!sonAmbosEnteros(tt1, tt2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: DIV_ENT requiere enteros (recibido '%s' y '%s'). Línea %d, columna %d.\u001B[0m%n",
                            tt1, tt2, lastLine, lastColumn);
                    }
                    else if (esCeroLiteral(v2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: División entera por cero. Línea %d, columna %d.\u001B[0m%n",
                            lastLine, lastColumn);
                    } else {
                        NodoToken var1 = buscarID(v1);
                        NodoToken var2 = buscarID(v2);

                        if (var1 != null && var1.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                            tieneErrores = true;
                        } else if (var2 != null && var2.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            String temp = genOperacion3D(t1, "//", t2); 
                            res.put("temp", temp);
                            res.put("valor", v1 + "//" + v2);
                        }
                    }
                    RESULT = res;
                :}
        | termino:e1 MOD factor:e2
                {:
                    HashMap<String,String> res = new HashMap<>();
                    String v1 = ((HashMap)e1).get("valor").toString();
                    String v2 = ((HashMap)e2).get("valor").toString();
                    String t1 = ((HashMap)e1).get("temp").toString();
                    String t2 = ((HashMap)e2).get("temp").toString();

                    String tt1 = obtenerTipoExpresion(v1);
                    String tt2 = obtenerTipoExpresion(v2);

                    if (!sonAmbosEnteros(tt1, tt2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: MOD requiere enteros (recibido '%s' y '%s'). Línea %d, columna %d.\u001B[0m%n",
                            tt1, tt2, lastLine, lastColumn);
                    }
                    else if (esCeroLiteral(v2)) {
                        tieneErrores = true;
                        res.put("temp","error");
                        res.put("valor","error");
                        System.err.printf("\u001B[31mXXX Error semántico: Módulo por cero. Línea %d, columna %d.\u001B[0m%n",
                            lastLine, lastColumn);
                    } else {
                        NodoToken var1 = buscarID(v1);
                        NodoToken var2 = buscarID(v2);

                        if (var1 != null && var1.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                            tieneErrores = true;
                        } else if (var2 != null && var2.getValor() == null) {
                            System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                            tieneErrores = true;
                        } else {
                            String temp = genOperacion3D(t1, "%", t2);
                            res.put("temp", temp);
                            res.put("valor", v1 + "%" + v2);
                        }
                    }
                    RESULT = res;
                :}
        | factor:f {: RESULT = f; :}
        ;


// FACTORES
factor ::= potencia:e1 POT potencia:e2
                {:
                    // Verificar que ambos factores sean números
                    HashMap<String,String> res = new HashMap<>();
                    String v1 = ((HashMap)e1).get("valor").toString();
                    String v2 = ((HashMap)e2).get("valor").toString();

                    if (!(v1.matches("^-?\\d+$") || v1.matches("^-?\\d*\\.\\d+$"))) {
                        System.err.printf("\u001B[31mXXX Error semántico: Operando izquierdo '%s' no es numérico en operación de potencia. Línea %d, columna %d.\u001B[0m%n",
                            v1, lastLine, lastColumn);
                        tieneErrores = true;
                        res.put("temp", "error");
                        res.put("valor", "error");
                    } else if (!(v2.matches("^-?\\d+$") || v2.matches("^-?\\d*\\.\\d+$"))) {
                        System.err.printf("\u001B[31mXXX Error semántico: Operando derecho '%s' no es numérico en operación de potencia. Línea %d, columna %d.\u001B[0m%n",
                            v2, lastLine, lastColumn);
                        tieneErrores = true;
                        res.put("temp", "error");
                        res.put("valor", "error");
                    } else {
                        String t1 = ((HashMap)e1).get("temp").toString();
                        String t2 = ((HashMap)e2).get("temp").toString();
                        String temp = genOperacion3D(t1, "^", t2);
                        res.put("temp", temp);
                        res.put("valor", v1 + "^" + v2); 
                    }
                    RESULT = res;
                :}
        | potencia:p {: RESULT = p; :}
        ;



// POTENCIAS
potencia ::= PAR_A expresion:e PAR_C {: RESULT = e; :}
    | operando:o {: RESULT = o; :}
;
    
//UN OPERANDO ES LA FORMA MÁS SENCILLA DE UNA OPERACIÓN
operando ::= ENTERO:a 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempInt();
            cod3D(temp + " = " + a);
            res.put("temp", temp);
            res.put("valor", a.toString());
            RESULT = res;
        :}
    | FLOTANTE:f 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempFloat();
            cod3D(temp + " = " + f);
            res.put("temp", temp);
            res.put("valor", f.toString());
            RESULT = res;
        :}
    | TRUE1 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempInt();
            cod3D(temp + " = true");
            res.put("temp", temp);
            res.put("valor", "true");
            RESULT = res;
        :}
    | FALSE1 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempInt();
            cod3D(temp + " = false");
            res.put("temp", temp);
            res.put("valor", "false");
            RESULT = res;
        :}
    | CHAR:c 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempInt();
            cod3D(temp + " = " + c);
            res.put("temp", temp);
            res.put("valor", c.toString());
            RESULT = res;
        :}
    | CADENA:s 
        {:
            HashMap<String,String> res = new HashMap<>();
            String temp = nuevaTempInt();
            cod3D(temp + " = " + s);
            res.put("temp", temp);
            res.put("valor", s.toString());
            RESULT = res;
        :}
| ID:id 
        {:
            HashMap<String,String> res = new HashMap<>();
            NodoToken var = buscarID(id.toString());

            if (var == null) {
                System.err.printf(
                    "\u001B[31mXXX Error semántico: variable '%s' no declarada. Línea %d, columna %d.\u001B[0m%n",
                    id.toString(), lastLine, lastColumn
                );
                tieneErrores = true;
                res.put("temp","error");
                res.put("valor","error");
            } else {
                String tipoVar = var.getTipo();
                String temp;

                if ("float".equals(tipoVar)) {
                    temp = nuevaTempFloat();
                } else {
                    temp = nuevaTempInt();
                }

                cod3D(temp + " = " + id);
                res.put("temp", temp);
                res.put("valor", id.toString());
            }

            RESULT = res;
        :}

    | elemento_arreglo:e {:
        HashMap<String, Object> elem = (HashMap<String, Object>) e;

        String nombre = (String) elem.get("nombre");
        Object indice = elem.get("indice"); 
        String temporal = (String) elem.get("temporal");

        HashMap<String,String> res = new HashMap<>();
        if (e != null) {
            String temp = nuevaTempInt();
            res.put("temp", temporal);
            NodoToken elementoArreglo = buscarID(nombre);
            if(elementoArreglo.getTipo() == "arreglo_entero"){
                String[] listaElementos = elementoArreglo.getValor().toString().replace("[", "").replace("]", "").split(",");
                if(listaElementos.length > Integer.parseInt(indice.toString())){

                    String valor = listaElementos[Integer.parseInt(indice.toString())].trim();
                    res.put("valor", valor);
                }else{
                    System.err.printf("\u001B[31mXXX Error semántico: Índice %s fuera de rango para arreglo '%s'. Línea %d, columna %d.\u001B[0m%n",
                        indice.toString(), nombre, lastLine, lastColumn);
                    tieneErrores = true;
                    res.put("temp", "error");
                    res.put("valor", "error");
                }
            }else{
                res.put("valor", "error");
            }
            
        } else {
            res.put("temp","error");
            res.put("valor","error");
        }

        RESULT = res;
    :}
    | MENOS operando:op 
        {:
            HashMap<String,String> res = new HashMap<>();
            if (op != null && !((HashMap)op).get("temp").equals("error")) {
                String t = ((HashMap)op).get("temp").toString();
                String v = ((HashMap)op).get("valor").toString();
                String temp = nuevaTempInt();
                cod3D(temp + " = -" + t);
                res.put("temp", temp);
                res.put("valor", "-" + v);
            } else {
                res.put("temp","error");
                res.put("valor","error");
            }
            RESULT = res;
        :}
    | llamada_funcion:llamada 
        {:
            HashMap<String,String> res = new HashMap<>();
            if (llamada != null) {
                res.put("temp", llamada.toString());
                res.put("valor", llamada.toString());
            } else {
                res.put("temp", "error");
                res.put("valor", "error");
            }
            RESULT = res;
        :}
    | incrementar:inc 
        {:
            HashMap<String,String> res = new HashMap<>();
            if (inc != null) {
                String temp = nuevaTempInt();
                cod3D(temp + " = " + inc.toString());
                res.put("temp", temp);
                res.put("valor", inc.toString());
            } else {
                res.put("temp","error");
                res.put("valor","error");
            }
            RESULT = res;
        :}
    | decrementar:dec 
        {:
            HashMap<String,String> res = new HashMap<>();
            if (dec != null) {
                String temp = nuevaTempInt();
                cod3D(temp + " = " + dec.toString());
                res.put("temp", temp);
                res.put("valor", dec.toString());
            } else {
                res.put("temp","error");
                res.put("valor","error");
            }
            RESULT = res;
        :}
    ;


// OPERADORES RELACIONALES
op_rel ::= MAYOR    {: RESULT = ">";  :}
    | MENOR        {: RESULT = "<";  :}
    | MAY_IGU      {: RESULT = ">="; :}
    | MEN_IGU      {: RESULT = "<="; :}
    | IGUAL        {: RESULT = "=="; :}
    | DIF          {: RESULT = "!="; :}
    ;

// ESTRUCTURAS DE CONTROL 

condicional ::=
    DECIDE OF
        {:
            contadorDecide++;
            contadorCase = 0;
            contadorElse = 0;

            scopeAnteriorDecide = currentHash;

            decideBaseLabel = currentHash + "_decide" + contadorDecide;

            crearSubAmbito(decideBaseLabel);
            currentHash = decideBaseLabel;


            decideConds  = new StringBuilder();
            decideBlocks = new StringBuilder();

            target3D = decideConds;

            cod3D("\n" + decideBaseLabel + ":");
        :}
    lista_casos
    cond_else_opt
    END DECIDE
        {:
            target3D = codigoIntermedio;
            codigoIntermedio.append(decideConds);
            codigoIntermedio.append(decideBlocks);

            cod3D(decideBaseLabel + "_end:");

            currentHash    = scopeAnteriorDecide;
            decideConds    = null;
            decideBlocks   = null;
            decideBaseLabel = null;


        :}
    ;

lista_casos ::= caso
              | lista_casos caso
              ;

caso ::=
    PAR_A expresion:e PAR_C FLECHA
        {:
            contadorCase++;

            String labelCaso = decideBaseLabel + "_caso" + contadorCase;

            String tempCond = ((HashMap)e).get("temp").toString();

            cod3D("if " + tempCond + " goto " + labelCaso);
        
                    currentHash = decideBaseLabel;
            String caseScopeTS = decideBaseLabel + "_TS_caso" + contadorCase;
            crearSubAmbito(caseScopeTS);

            String scopeAnterior = currentHash;
            currentHash = caseScopeTS;

            target3D = decideBlocks;

            cod3D("\n" + labelCaso + ":");

                        RESULT = scopeAnterior;

        :}
    bloque
        {:
            cod3D("goto " + decideBaseLabel + "_end");

            target3D = decideConds;
        :}
    | PAR_A error PAR_C FLECHA bloque
    ;

cond_else_opt ::=
      /* vacío */
        {:
            cod3D("goto " + decideBaseLabel + "_end");
        :}
    | ELSE FLECHA
        {:
            String labelElse = decideBaseLabel + "_else";

            cod3D("goto " + labelElse);

            currentHash = decideBaseLabel;
            String elseScopeTS = decideBaseLabel + "_TS_else";
            crearSubAmbito(elseScopeTS);

            String scopeAnterior = currentHash;
            currentHash = elseScopeTS;

            target3D = decideBlocks;
            cod3D("\n" + labelElse + ":");

                        RESULT = scopeAnterior;

        :}
      bloque
        {:
            cod3D("goto " + decideBaseLabel + "_end");

            currentHash = (String) RESULT;

            target3D = decideConds;
        :}
    ;

bucle_loop ::=
    LOOP
    {:
        // Crear scope de tabla de símbolos 
        contadorLoop++;
        String loopScope = currentHash + "_loop" + contadorLoop;
        crearSubAmbito(loopScope);
        cod3D("\n" + currentHash + "_loop" + contadorLoop + ":");


        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = loopScope;

        // Codigo intermedio

        RESULT = anteriorScope;
    :}
    lista_sentencias
    EXIT WHEN expresion:e1 FIN_E
    {: 
        // Codigo intermedio NO HAY VALIDACION SEMANTICA
        cod3D("if " + ((HashMap)e1).get("temp").toString() + " goto " + currentHash + "_endloop");
    :}
    END LOOP FIN_E
    {:
        // Codigo intermedio
        cod3D("goto " + currentHash);
        cod3D(currentHash + "_endloop:");

        // Restaurar el scope previo
        currentHash = (String) RESULT;

    :}
    ;

bucle_for ::=
    FOR1
    asignacion:e
    step ENTERO:valor
    direccion:dir expresion:limite
    {:

        contadorFor++;
        String forScope = currentHash + "_for" + contadorFor;
        cod3D("\n" + forScope + ":");
        String temporalContador = nuevaTempInt();
        String temporalLimite = nuevaTempInt();
        String temporalValidacion = nuevaTempInt();
        cod3D(temporalContador + " = " + e);
        cod3D(temporalLimite + " = " + ((HashMap)limite).get("temp").toString());
        int numeroStep = Integer.parseInt(valor.toString());
        if(numeroStep > 0){
            if (dir.equals("downto")) {
                cod3D(temporalValidacion + " = " + temporalContador + " < " + temporalLimite);
            } else {
                cod3D(temporalValidacion + " = " + temporalContador + " > " + temporalLimite);
            }
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       El valor de STEP debe ser mayor que 0. Línea %d, columna %d.\u001B[0m %n", lastLine, lastColumn);
            tieneErrores = true;
        }    
        
        crearSubAmbito(forScope);
        cod3D("if " + temporalValidacion + " goto " + forScope + "_endfor");
        if (dir.equals("downto")) {
            cod3D(e + " = " + temporalContador + " - " + valor);
        } else {
            cod3D(e + " = " + temporalContador + " + " + valor);
        }

        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = forScope;
        RESULT = anteriorScope;
        
    :}
        DO bloque
    {:
        String forFinal = currentHash + "_endfor";
        cod3D("goto " +currentHash);
        cod3D("\n" +forFinal+ ":");
        // Recupera el scope anterior
        currentHash = (String) RESULT;

    :}
    ;

step ::= /* vacío */
       | STEP
       ;

direccion ::= TO:to {: RESULT = to.toString(); :}
            | DOWNTO:downto {: RESULT = downto.toString(); :}
            ;

//++++++++++++++++++++++++++++++++ARREGLOS+++++++++++++++++++++++++++++

lista_elementos_arreglo_entero ::= ENTERO:entero {: 
    // Primer elemento
    ArrayList<String> elementos = new ArrayList<>();
    elementos.add(entero.toString());
    RESULT = elementos;

:}
| lista_elementos_arreglo_entero:lista COMA ENTERO:entero {: 
    // Agregar elemento a la lista existente
    if (lista != null && lista instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) lista;
        elementosLista.add(entero.toString());
        RESULT = elementosLista;

    } else {
        // Si por alguna razón la lista no es válida, crear una nueva
        ArrayList<String> elementos = new ArrayList<>();
        elementos.add(entero.toString());
        RESULT = elementos;

    }
:}
;
package salchichon_script;

import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.ArrayList;
import java.io.FileWriter;

// PARSER
parser code
{:
    /**
    * Representa una entrada en la tabla de símbolos (token semántico) de Salchichón Script.
    * Guarda tipo, identificador, valor y metadatos de posición (línea/columna).
    */
    public class NodoToken{
        String tipo;
        String id;
        String valor;
        String linea;
        String columna;

        /** Crea un nodo vacío (campos nulos). */
        public NodoToken() {
        }

        /** @return el tipo semántico del símbolo. */
        public String getTipo() {
            return tipo;
        }

        /** @param tipo nuevo tipo semántico. */
        public void setTipo(String tipo) {
            this.tipo = tipo;
        }

        /** @return el identificador (nombre) del símbolo. */
        public String getId() {
            return id;
        }

        /** @param id nuevo identificador. */
        public void setId(String id) {
            this.id = id;
        }

        /** @return el valor asociado al símbolo. */
        public String getValor() {
            return valor;
        }

        /** @param valor nuevo valor semántico. */
        public void setValor(String valor) {
            this.valor = valor;
        }

        /** @return línea 1-based en el archivo fuente. */
        public String getLinea() {
            return linea;
        }

        /** @param linea línea 1-based en el archivo fuente. */
        public void setLinea(String linea) {
            this.linea = linea;
        }

        /** @return columna 1-based en el archivo fuente. */
        public String getColumna() {
            return columna;
        }

        /** @param columna columna 1-based en el archivo fuente. */
        public void setColumna(String columna) {
            this.columna = columna;
        }

        /** @return representación legible del símbolo y sus metadatos. */
        @Override
        public String toString() {
            return "NodoToken \n{\n" +
                " tipo = " + tipo + '\n' +
                " id = " + id + '\n' +
                " valor = " + valor + '\n' +
                " linea = " + linea + '\n' +
                " columna = " + columna + '\n' +
            '}';
        }
    }

    HashMap<String, ArrayList<NodoToken>> listaTablasSimbolos = new HashMap<>();
    String currentHash;
    String globalHash = "global1TS";
    int contadorLoop = 0;
    int contadorFor = 0;
    int contadorDecide = 0;
    int contadorCase = 0;
    int contadorElse = 0;

    /**
    * Inicializa la tabla de símbolos global y registra funciones de sistema
    * disponibles por defecto (imprimir/leer).
    * Efectos: Crea el scope global, lo establece como actual y agrega
    * dos entradas de tipo "funcion_sistema".
    */
    public void inicarTS() {
        listaTablasSimbolos.put(globalHash, new ArrayList<>());
        currentHash = globalHash;

        NodoToken printFunc = new NodoToken();
        printFunc.setTipo("funcion_sistema");
        printFunc.setId("imprimir");
        printFunc.setValor("void");
        printFunc.setLinea("0");
        printFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(printFunc);

        NodoToken readFunc = new NodoToken();
        readFunc.setTipo("funcion_sistema");
        readFunc.setId("leer");
        readFunc.setValor("string");
        readFunc.setLinea("0");
        readFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(readFunc);
    }

    /**
    * Vuelca todas las tablas de símbolos a un archivo de texto (tokens.txt)
    * en formato legible.
    * Efectos: Escribe en disco. No altera el estado semántico.
    * Errores: Registra en consola si no se puede escribir el archivo.
    */
    public void imprimirTablasSimbolos(){
        try{
            FileWriter writer = new FileWriter("tokens.txt");
        for(String key: listaTablasSimbolos.keySet()){
                //System.out.println("------------------Tabla de simbolo : " + key);
                writer.write("Tabla de simbolos: " + key + "\n");
                writer.write("********Valores*********** \n");
                //System.out.println("********Valores*********** ");
            for(NodoToken item : listaTablasSimbolos.get(key)){
                    //System.out.println(item.toString());
                    writer.write(item.toString() + "\n");
                }
                //System.out.println("------------------Fin tabla de simbolos : " + key);
                writer.write("------------------Fin tabla de simbolos : " + key + "\n\n");
            }
            writer.close();
        }catch(Exception e){
            System.out.println("Error al escribir el archivo de tokens: " + e.getMessage());
        }
    }
    
    /**
    * Busca el tipo asociado a un identificador dentro de una tabla específica.
    * @param tabla tabla de símbolos a inspeccionar.
    * @param id    identificador cuyo tipo se desea recuperar (comparado contra {token.valor}).
    * @return tipo encontrado o cadena vacía si no existe coincidencia.
    */
    public String getTipo(ArrayList<NodoToken> tabla, String id){
        String tipo = "";
        for(NodoToken token : tabla){
            if(id.equals(token.getValor())){
                tipo = token.getTipo();
            }
        }
        System.out.println("tipo: "+tipo);
        return tipo;
    }

    /**
    * Busca un identificador primero en el ámbito actual y luego en el global.
    * @param id identificador (nombre) a buscar.
    * @return el {NodoToken} si existe; de lo contrario {null}.
    */
    public NodoToken buscarID(String id){
        System.out.println(">>> [DEBUG] Buscando ID: '" + id + "' en ámbito: " + currentHash);
        
        if(listaTablasSimbolos.containsKey(currentHash)){
            for(NodoToken tok : listaTablasSimbolos.get(currentHash)){
                if(tok.getId().equals(id)) {
                    System.out.println(">>> [DEBUG] Encontrado en ámbito actual: " + tok.getId() + " = " + tok.getValor());
                    return tok;
                }
            }
        }
        
        for(NodoToken tok : listaTablasSimbolos.get(globalHash)){
            if(tok.getId().equals(id)) {
                System.out.println(">>> [DEBUG] Encontrado en ámbito global: " + tok.getId() + " = " + tok.getValor());
                return tok;
            }
        }
        
        System.out.println(">>> [DEBUG] NO encontrado: " + id);
        return null;
    }

    /**
    * Crea un nuevo ámbito (scope) copiando todos los símbolos visibles del
    * ámbito actual, y lo registra en {#listaTablasSimbolos}.
    * @param nombreScope nombre único del nuevo ámbito.
    * Efectos: No cambia {#currentHash}; solo registra el nuevo scope con símbolos heredados.
    */
    public void crearSubAmbito(String nombreScope) {
        ArrayList<NodoToken> nuevo = new ArrayList<>();

        // Copiar los simbolos anteriores al nuevo scope
        if (listaTablasSimbolos.containsKey(currentHash)) {
            for (NodoToken tok : listaTablasSimbolos.get(currentHash)) {
                NodoToken copia = new NodoToken();
                copia.setTipo(tok.getTipo());
                copia.setId(tok.getId());
                copia.setValor(tok.getValor());
                copia.setLinea(tok.getLinea());
                copia.setColumna(tok.getColumna());
                nuevo.add(copia);
            }
        }

        // Registrar el nuevo scope con los simbolos heredados
        listaTablasSimbolos.put(nombreScope, nuevo);

        System.out.println(">>> [DEBUG] Nuevo ámbito creado: " + nombreScope + " heredando de " + currentHash);
    }


    StringBuilder codigoIntermedio = new StringBuilder();
    int tempCont = 0;
    int floatTempCont = 0;
    int labelCont = 0;

    /**
    * Genera el nombre de un temporal entero único (t1, t2, ...).
    * @return identificador del temporal generado.
    */
    String nuevaTempInt() {
        return "t" + (++tempCont);
    }

    /**
    * Genera el nombre de un temporal de punto flotante único (f1, f2, ...).
    * @return identificador del temporal generado.
    */
    String nuevaTempFloat() {
        return "f" + (++floatTempCont);
    }

    /**
    * Añade una línea de código de tres direcciones al buffer.
    * @param codigo instrucción 3AC ya formateada.
    */
    void cod3D(String codigo) {
        codigoIntermedio.append(codigo).append("\n");
        System.out.println(">>> [3AC] " + codigo);
    }

    /**
    * Emite 3AC para una operación binaria con carga de operandos a temporales si hace falta.
    * @param op1      operando izquierdo (temporal existente o nombre/valor literal).
    * @param operador símbolo del operador (p.ej., "+", "-", "*", "/", "%", "&&", "||", "^").
    * @param op2      operando derecho (temporal existente o nombre/valor literal).
    * @return nombre del temporal resultado.
    */
    public String genOperacion3D(String op1, String operador, String op2) {
        String temp1, temp2, tempRes;
        
        // Si el operando izquierdo no es temporal, lo cargamos a uno nuevo
        if (op1.startsWith("t") || op1.startsWith("f")) {
            temp1 = op1;
        } else {
            temp1 = nuevaTempInt();
            cod3D(temp1 + " = " + op1);
        }

        // Si el operando derecho no es temporal, lo cargamos a otro
        if (op2.startsWith("t") || op2.startsWith("f")) {
            temp2 = op2;
        } else {
            temp2 = nuevaTempInt();
            cod3D(temp2 + " = " + op2);
        }

        // Crear resultado
        tempRes = nuevaTempInt();
        cod3D(tempRes + " = " + temp1 + " " + operador + " " + temp2);
        return tempRes;
    }



    // ==================== Validacion semantica ====================

    /**
    * Valida que el valor literal/asignado sea compatible con el tipo declarado.
    * @param tipoEsperado tipo declarado de la variable destino (int, float, boolean, char, string).
    * @param valorAsignado representación textual del valor/expresión ya reducida.
    * @param linea línea de la fuente (1-based) para diagnóstico.
    * @param columna columna de la fuente (1-based) para diagnóstico.
    * 
    * Efectos: Marca {#tieneErrores} y escribe errores si hay incompatibilidades.
    */
    public void validarAsignacionTipo(String tipoEsperado, String valorAsignado, int linea, int columna) {
        if (valorAsignado == null || tipoEsperado == null) return;

        switch (tipoEsperado) {
            case "int":
                try {
                    Integer.parseInt(valorAsignado);
                } catch (NumberFormatException e) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'int'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "float":
                try {
                    Float.parseFloat(valorAsignado);
                } catch (NumberFormatException e) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'float'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "boolean":
                if (!(valorAsignado.equals("true") || valorAsignado.equals("false"))) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'boolean'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "char":
                if (valorAsignado.length() != 3 || valorAsignado.charAt(0) != '\'' || valorAsignado.charAt(2) != '\'') {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'char'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "string":
                if (!valorAsignado.startsWith("\"") || !valorAsignado.endsWith("\"")) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'string'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            default:
                System.err.printf("\u001B[33m [ADVERTENCIA] Tipo '%s' no reconocido para validación semántica.\u001B[0m%n", tipoEsperado);
                break;
        }
    }

    /** @return {true} si el literal representa cero (entero o flotante simple). */
    boolean esCeroLiteral(String v) {
        return "0".equals(v) || "0.0".equals(v) || "0.".equals(v) || ".0".equals(v);
    }

    /** @return {true} si el tipo es exactamente "int". */
    boolean esEnteroTipo(String t) {
        return "int".equals(t);
    }
    
    /** @return {true} si el tipo es exactamente "float". */
    boolean esFloatTipo(String t) {
        return "float".equals(t);
    }

    /** @return {true} si ambos tipos son enteros. */
    boolean sonAmbosEnteros(String t1, String t2) {
        return esEnteroTipo(t1) && esEnteroTipo(t2);
    }


    /**
    * Regla de promoción de tipos para multiplicación.
    * @param tL tipo del operando izquierdo.
    * @param tR tipo del operando derecho.
    * @return "int" si ambos son int; "float" si hay mezcla int/float; "desconocido" en otro caso.
    */
    String tipoNumericoResultanteProducto(String tL, String tR) {
        if ("int".equals(tL) && "int".equals(tR)) return "int";
        if (( "int".equals(tL) || "float".equals(tL) ) &&
            ( "int".equals(tR) || "float".equals(tR) )) return "float";
        return "desconocido";
    }

    /**
    * @return {true} si ambos tipos son numéricos (int o float).
    */
    boolean ambosNumericos(String tL, String tR) {
        return ( "int".equals(tL) || "float".equals(tL) ) &&
            ( "int".equals(tR) || "float".equals(tR) );
    }
    // --- helpers ---

    /**
    * Hit de operador encontrado al parsear una expresión a nivel tope.
    * Contiene posición (índice en la cadena) y el lexema del operador.
    */
    static class OpHit { 
        int pos; String op; 
        OpHit(int p, String o) { pos = p; op = o; } 
    }

    /**
    * Determina si el '-' en la posición dada actúa como binario (resta) y no como unario (negación).
    * @param s cadena de la expresión.
    * @param i índice del carácter '-'.
    * @return {true} si se interpreta como binario; {false} si es unario.
    */
    boolean isBinaryMinus(String s, int i) {
        int j = i - 1;
        while (j >= 0 && Character.isWhitespace(s.charAt(j))) j--;
        if (j < 0) return false; // inicio = unario
        char L = s.charAt(j);
        return Character.isLetterOrDigit(L) || L==')' || L==']' || L=='\'' || L=='"';
    }

    /**
    * Busca el primer (o último) operador de un conjunto permitido al "nivel tope" (no dentro de paréntesis
    * ni dentro de literales de cadena/carácter).
    * @param s           expresión completa.
    * @param ops         lista de operadores a detectar (p.ej. {"+","-"}).
    * @param preferLast  si {true}, devuelve el último hallado; si {false}, el primero.
    * @return {OpHit} con posición y operador, o {null} si no encuentra.
    */
    OpHit findTopLevelOp(String s, String[] ops, boolean preferLast) {
        int depth = 0;
        boolean inStr = false, inChar = false;
        OpHit hit = null;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            // literales
            if (inStr) { if (c=='"'  && s.charAt(i-1)!='\\') inStr=false; continue; }
            if (inChar){ if (c=='\'' && s.charAt(i-1)!='\\') inChar=false; continue; }
            if (c=='"')  { inStr=true;  continue; }
            if (c=='\'') { inChar=true; continue; }

            // paréntesis
            if (c=='(') { depth++; continue; }
            if (c==')') { depth--; continue; }
            if (depth!=0) continue;

            // operador de dos caracteres: //
            if (c=='/' && i+1<s.length() && s.charAt(i+1)=='/') {
                for (String op: ops) if (op.equals("\\/\\/")) {
                    OpHit h = new OpHit(i, "\\/\\/");
                    if (!preferLast) return h; else hit = h;
                }
                i++;
                continue;
            }

            // operadores de un carac
            for (String op: ops) if (op.length()==1 && c==op.charAt(0)) {
                if (op.equals("-") && !isBinaryMinus(s,i)) continue; // '-' unario, ignora
                OpHit h = new OpHit(i, op);
                if (!preferLast) return h; else hit = h;
            }
        }
        return hit;
    }

    /**
    * Elimina paréntesis exteriores que envuelven completamente la expresión (p. ej. "(1+(2*3))" -> "1+(2*3)").
    * Respeta el balanceo interno.
    * @param s expresión original.
    * @return expresión sin paréntesis exteriores redundantes.
    */
    String stripOuterParens(String s) {
        if (s==null) return null;
        s = s.trim();
        while (s.length()>=2 && s.charAt(0)=='(' && s.charAt(s.length()-1)==')') {
            int depth=0; boolean ok=true;
            for (int i=0;i<s.length();i++){
                char c=s.charAt(i);
                if (c=='(') depth++;
                else if (c==')'){ depth--; if (depth<0){ok=false;break;} }
                if (depth==0 && i<s.length()-1){ ok=false; break; }
            }
            if (!ok) break;
            s = s.substring(1,s.length()-1).trim();
        }
        return s;
    }

    /**
    * Inferencia de tipo para una expresión textual ya tokenizada/reducida.
    * Soporta literales, identificadores, suma/resta, producto/división/módulo,
    * división entera (//) y potencia (^), con respeto a precedencias mediante
    * búsqueda de operadores a nivel tope.
    * @param valor objeto cuya representación {toString()} se interpreta como expresión.
    * @return tipo inferido: "int", "float", "boolean", "string", "char" o "desconocido".
    * Reglas relevantes:
    * <ul>
    *   <li>{int / int -> float}</li>
    *   <li>{int // int -> int} (solo si ambos enteros)</li>
    *   <li>{int % int -> int} (solo si ambos enteros)</li>
    *   <li>{int * int -> int}, mixto con float -> {float}</li>
    *   <li>{^} devuelve {int} si ambos son int, {float} si ambos son float, {desconocido} en mezcla</li>
    * </ul>
    * También consulta {#buscarID(String)} si la expresión es un identificador simple.
    */
    public String obtenerTipoExpresion(Object valor) {
        if (valor == null) return "desconocido";
        String v = valor.toString().trim();
        if (v.isEmpty()) return "desconocido";
        v = stripOuterParens(v);

        if (v.matches("^-?\\d+$")) return "int";
        if (v.matches("^-?\\d*\\.\\d+$")) return "float";
        if (v.equals("true") || v.equals("false")) return "boolean";
        if (v.startsWith("\"") && v.endsWith("\"")) return "string";
        if (v.startsWith("'") && v.endsWith("'") && v.length()==3) return "char";

        OpHit hit = findTopLevelOp(v, new String[]{"+","-"}, true);
        if (hit != null) {
            String L = v.substring(0, hit.pos).trim();
            String R = v.substring(hit.pos + 1).trim();
            String tL = obtenerTipoExpresion(L);
            String tR = obtenerTipoExpresion(R);
            if (hit.op.equals("+")) {
                if (ambosNumericos(tL,tR)) return ("float".equals(tL)||"float".equals(tR)) ? "float" : "int";
                if (("string".equals(tL) && "string".equals(tR)) ||
                    ("char".equals(tL) && "char".equals(tR))) return "string";
                return "desconocido";
            } else { // '-'
                return ambosNumericos(tL,tR) ? (("float".equals(tL)||"float".equals(tR)) ? "float" : "int") : "desconocido";
            }
        }

        hit = findTopLevelOp(v, new String[]{"\\/\\/", "*", "/", "%", "^"}, false);
        if (hit != null) {
            String L, R;
            if ("\\/\\/".equals(hit.op)) {
                L = v.substring(0, hit.pos).trim();
                R = v.substring(hit.pos + 2).trim();
            } else {
                L = v.substring(0, hit.pos).trim();
                R = v.substring(hit.pos + 1).trim();
            }
            String tL = obtenerTipoExpresion(L);
            String tR = obtenerTipoExpresion(R);
            switch (hit.op) {
                case "*":
                    return tipoNumericoResultanteProducto(tL, tR);
                case "/":
                    return ambosNumericos(tL, tR) ? "float" : "desconocido";
                case "\\/\\/":
                    return ("int".equals(tL) && "int".equals(tR)) ? "int" : "desconocido";
                case "%":
                    return ("int".equals(tL) && "int".equals(tR)) ? "int" : "desconocido";
                case "^":
                    if ("int".equals(tL) && "int".equals(tR)) return "int";
                    if ("float".equals(tL) && "float".equals(tR)) return "float";
                    return "desconocido";
            }
        }

        NodoToken tok = buscarID(v);
        if (tok != null) return tok.getTipo();

        return "desconocido";
    }



/**
 * Verifica compatibilidad de tipos para operadores aritméticos/concatenación simples.
 * @param t1 tipo izquierdo.
 * @param t2 tipo derecho.
 * @return {true} si ambos tipos son iguales y pertenecen al conjunto soportado
 *         (int, float, string, char, boolean); en otro caso {false}.
 * Nota: No realiza promoción numérica; úsese junto con reglas específicas.
 */
    public boolean sonTiposCompatibles(String t1, String t2) {
        if (t1.equals("int") && t2.equals("int")) return true;
        if (t1.equals("float") && t2.equals("float")) return true;
        if (t1.equals("string") && t2.equals("string")) return true; // concatenacion
        if (t1.equals("char") && t2.equals("char")) return true;     // concatenacion de chars
        if (t1.equals("boolean") && t2.equals("boolean")) return true;
        return false;
    }

    /**
    * Indica si un identificador ya existe en una tabla de símbolos dada.
    * @param currentHash hash/nombre del scope a revisar.
    * @param id          identificador a buscar.
    * @return {true} si existe una entrada con ese id; de lo contrario {false}.
    */
    public boolean esIdExistente(String currentHash, String id) {

        if (listaTablasSimbolos.containsKey(currentHash)) {
            for (NodoToken existente : listaTablasSimbolos.get(currentHash)) {
                if (existente.getId().equals(id)) {
                    return true;
                }
            }
        }
        return false;
    }


    // ==================== Manejo de errores ====================

    public boolean tieneErrores = false;

    // Para recordar última posición válida
    private int lastLine = 1;
    private int lastColumn = 1;

    /**
    * Intercepta el escáner para recordar la última posición válida (línea/columna)
    * y así poder reportar errores más precisos cuando el símbolo sea nulo.
    * @return símbolo leído por el escáner subyacente.
    * @throws Exception propagadas por el escáner.
    */
    @Override
    public Symbol scan() throws Exception {
        Symbol sym = super.scan();
        if (sym != null) {
            if (sym.left >= 0) lastLine = sym.left + 1;
            if (sym.right >= 0) lastColumn = sym.right + 1;
        }
        return sym;
    }

    // Errores recuperables

    /**
    * Manejador de errores sintácticos recuperables.
    * Marca {#tieneErrores} y reporta el token con su posición aproximada.
    * @param s símbolo problemático (puede ser nulo).
    */
    @Override
    public void syntax_error(Symbol s) {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m XXX Error sintáctico recuperable XXX :       Token '%s' en línea %d, columna %d.\u001B[0m %n", lexema, linea, columna);
    }

    // Errores no recuperables

    /**
    * Manejador de errores sintácticos no recuperables.
    * Marca {#tieneErrores} y lanza la condición tras imprimir diagnóstico.
    * @param s símbolo problemático (puede ser nulo).
    * @throws Exception para detener el parseo según la política del parser.
    */
    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m     XXX Error sintáctico crítico XXX :       Token '%s' en línea %d, columna %d. \u001B[0m %n", lexema, linea, columna);
    }
:}

action code
{:
    // Codigo de usuario - fase de analisis
    String tmp="";
:}

// TERMINALES
terminal PAR_A, PAR_C, BLO_A, BLO_C, COMA, FLECHA, FIN_E, ASIGN, COR_A, COR_C, COMILLA_SIMP, CADENA_CHAR;
terminal MAS, MENOS, POR, DIV, DIV_ENT, MOD, POT;
terminal AND, OR, NOT;
terminal INC, DEC;
terminal MAYOR, MENOR, MAY_IGU, MEN_IGU, IGUAL, DIF;
terminal INT1, CHAR1, STR1, FLOAT1, BOOL1, LET, VOID, TRUE1, FALSE1, DECIDE;
terminal OF, ELSE, END, LOOP, EXIT, WHEN, FOR1, STEP, TO, DOWNTO, DO;
terminal RETURN, BREAK;
terminal INIT;

terminal ENTERO, FLOTANTE, CHAR, ID;
terminal IMPRIMIR, LEER, MAIN, CADENA;

// NO TERMINALES
non terminal Object program;
non terminal main_funcion, elemento_global, lista_global;
non terminal String tipo, tipo_funcion;
non terminal declaracion;
non terminal bloque, lista_sentencias, lista_sentencias_opt, sentencia, expr_opc, llamada_funcion, parametros_llamada, imprimir, leer;
non terminal funcion, parametros_opt, lista_parametros, parametro;
non terminal asignacion, asignacion_dec;
non terminal expresion;
non terminal expresion_arit, termino, factor, potencia, operando, elem_arr;
non terminal op_rel, incrementar, decrementar;
non terminal condicional, lista_casos, caso, cond_else_opt, bucle_loop, bucle_for, step, direccion;
non terminal lista_elementos_arreglo_entero, lista_char, diferente_asignacion, arreglo_char, declaracion_arreglo_entero, declaracion_arreglo_char, asignacion_arreglo; 
non terminal declara_func, declara_main_func;

// PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left IGUAL, DIF;
precedence left MAYOR, MENOR, MAY_IGU, MEN_IGU;
precedence left MAS, MENOS;
precedence left POR, DIV, DIV_ENT, MOD;
precedence right POT;
precedence right NOT;

// PRODUCCIONES

start with program;

program ::= {:  
                System.out.println("generando tabla de símbolos");
                inicarTS();
            :}
                lista_global main_funcion lista_global
            {:
                imprimirTablasSimbolos();

                // Guardar codigo 3d a archivo
                try {
                    java.nio.file.Files.write(
                        java.nio.file.Paths.get("intermedio.txt"),
                        codigoIntermedio.toString().getBytes()
                    );
                    System.out.println(">>> [3AC] Código intermedio guardado en intermedio.txt");
                } catch (Exception e) {
                    System.err.println("MAL" + e.getMessage());
                }
                System.out.println("fin de ejecución");

            :}
            ;
            
lista_global ::= elemento_global lista_global
    | /* vacío */
    ;

elemento_global ::= sentencia
    | funcion
    {: System.out.println("Fin variables globales"); :}
    ;

main_funcion ::= declara_main_func PAR_A PAR_C bloque
    | declara_main_func bloque
    | declara_main_func error
    ;

declara_main_func ::= INIT VOID:tipo MAIN:main
{:
    NodoToken func = new NodoToken();
    func.setId(main.toString());
    func.setTipo(tipo.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + main.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función main creada: " + currentHash);

    // CODIGO INTERMEDIO
    cod3D("\n" + main + ":");
:};

// ======== DECLARACIÓN DE VARIABLES ========
tipo ::= INT1 {: RESULT = "int"; :}
    | STR1 {: RESULT = "string"; :}
    | FLOAT1 {: RESULT = "float"; :}
    | BOOL1 {: RESULT = "boolean"; :}
    | CHAR1 {: RESULT = "char"; :}
    ;

tipo_funcion ::= tipo:t {: RESULT = t; :}
    | VOID {: RESULT = "void"; :}
    ;

//+++++++++++++++++++++BLOQUE++++++++++++++++++++++++++++++++++

bloque ::= BLO_A lista_sentencias_opt BLO_C
         | BLO_A error BLO_C
         ;

lista_sentencias_opt ::= /* vacío */
                     | lista_sentencias
                     ;

lista_sentencias ::= sentencia
                  | lista_sentencias sentencia
                  ;

asignacion_arreglo::= 
    ID:nombreVar ASIGN ID:nombreArreglo COR_A expresion:indice COR_C
    {:
        NodoToken varToken = buscarID(nombreVar.toString());
        NodoToken arregloToken = buscarID(nombreArreglo.toString());
        var tipoVar = varToken != null ? varToken.getTipo() : "desconocido";
        var tipoArreglo = arregloToken != null ? arregloToken.getTipo() : "desconocido";
        if(varToken != null && arregloToken != null){    
            if(tipoVar.matches("int") && tipoArreglo.matches("arreglo_entero")){
                System.out.println(">>> [DEBUG] Asignación válida a arreglo entero: " + nombreVar + " = " + nombreArreglo + "[" + indice + "]");
                varToken.setValor(nombreArreglo.toString() + "[" + indice.toString() + "]");
            } 
            else if(tipoVar.matches("char") && tipoArreglo.matches("arreglo_char")){
                System.out.println(">>> [DEBUG] Asignación válida a arreglo Char: " + nombreVar + " = " + nombreArreglo + "[" + indice + "]");
                varToken.setValor(nombreArreglo.toString() + "[" + indice.toString() + "]");
            }
            else {
                System.err.printf("\u001B[31mXXX Error semántico: Tipo incompatible en asignación a arreglo. Línea %d, columna %d.\u001B[0m%n",
                    lastLine, lastColumn);
                tieneErrores = true;
            }
        }else{
            System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' o arreglo %s no declarados. Línea %d, columna %d.\u001B[0m%n",
                nombreVar.toString(), nombreArreglo.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
    :}
    | ID:nombreVar ASIGN COR_A lista_elementos_arreglo_entero:elementos COR_C
        {:
            NodoToken varToken = buscarID(nombreVar.toString());
            var tipoVar = varToken != null ? varToken.getTipo() : "desconocido";
            if(varToken != null){
                StringBuilder elementosStr = new StringBuilder();
                elementosStr.append("[");
                if (elementos != null && elementos instanceof ArrayList) {
                    ArrayList<String> elementosLista = (ArrayList<String>) elementos;
                    for (int i = 0; i < elementosLista.size(); i++) {
                        if (i > 0) elementosStr.append(", ");
                        elementosStr.append(elementosLista.get(i));
                    }
                    System.out.println(">>> [DEBUG] Arreglo con " + elementosLista.size() + " elementos: " + elementosStr.toString());
                } else {
                    elementosStr.append("]");
                    System.out.println(">>> [DEBUG] Arreglo sin elementos válidos");
                }
                
                elementosStr.append("]");
                
                varToken.setValor(elementosStr.toString());
                varToken.setLinea(String.valueOf(lastLine));
                varToken.setColumna(String.valueOf(lastColumn));
            }
        :}
    | ID:nombreVar ASIGN COR_A arreglo_char:elementos COR_C
    ;

sentencia ::= declaracion FIN_E
    | declaracion_arreglo_entero FIN_E
    | declaracion_arreglo_char FIN_E
    | asignacion_arreglo FIN_E
    | asignacion FIN_E
    | llamada_funcion FIN_E
    | imprimir FIN_E
    | leer FIN_E
    | RETURN expr_opc FIN_E
    | BREAK FIN_E
    | incrementar FIN_E
    | decrementar FIN_E
    | condicional FIN_E
    | bucle_loop 
    | bucle_for
    | error FIN_E
    ;

incrementar ::= ID INC;
decrementar ::= ID DEC;

expr_opc ::=
      expresion
    | /* ε */
    ;

llamada_funcion ::= ID PAR_A parametros_llamada PAR_C;

parametros_llamada ::= expresion
                        | expresion COMA parametros_llamada
                        |
                        ;

imprimir ::= IMPRIMIR PAR_A expresion:e PAR_C
{:
    String valorReal = "";
    String tempValor = "";

    if (e != null) {
        if (e instanceof java.util.HashMap) {
            valorReal = ((HashMap)e).get("valor").toString();
            tempValor = ((HashMap)e).get("temp").toString();
        } else {
            valorReal = e.toString();
            tempValor = valorReal;
        }

        NodoToken posibleVar = buscarID(valorReal);

        cod3D("print " + tempValor);

        NodoToken imp = new NodoToken();
        imp.setTipo("llamada_funcion_sistema");
        imp.setId("imprimir");
        imp.setValor(valorReal);
        imp.setLinea(String.valueOf(lastLine));
        imp.setColumna(String.valueOf(lastColumn));
        listaTablasSimbolos.get(currentHash).add(imp);

        System.out.println(">>> [DEBUG] Uso de imprimir() en " + currentHash + 
                           " con valor: " + valorReal + 
                           " (temp: " + tempValor + ")");
    } else {
        System.err.printf("\u001B[31mXXX Error semántico: llamada a imprimir() sin expresión válida. Línea %d, columna %d.\u001B[0m%n",
            lastLine, lastColumn);
        tieneErrores = true;
    }

    RESULT = null; 
:};


leer ::= LEER PAR_A PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("entrada_usuario");
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash);
:}
| LEER PAR_A ID:var PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("asigna_a:" + var.toString());
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash + ", asignando a " + var);
:};


//+++++++++++++++++++++FUNCIONES++++++++++++++++++++++++++++++++

funcion ::= declara_func PAR_A parametros_opt:params PAR_C
             bloque
             {:
                currentHash = globalHash;
                System.out.println(">> [TS] Regresando a tabla global.");
            :}
          | declara_func PAR_A parametros_opt PAR_C error
          ;

declara_func::= tipo_funcion:tipoFun ID:nombreFun
{:
    NodoToken func = new NodoToken();
    func.setId(nombreFun.toString());
    func.setTipo(tipoFun.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + nombreFun.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función creada: " + currentHash);


    // CODIGO INTERMEDIO
    cod3D("\n" + nombreFun + ":");
:};

parametros_opt ::= lista_parametros
                 | // VACIO
                 ;

lista_parametros ::= parametro
                  | lista_parametros COMA parametro
                  ;

// TO-DO: AGREGAR PARAMETROS A codigo intermedio 
parametro ::= tipo:ti ID:nombreParam
    {:

        if (esIdExistente(currentHash, nombreParam.toString())) {
            System.err.printf("\u001B[31mXXX Error semántico: Parámetro '%s' ya declarado en función. Línea %d, columna %d.\u001B[0m%n",
                nombreParam.toString(), lastLine, lastColumn);
            tieneErrores = true;
        } else {
            NodoToken param = new NodoToken();
            param.setTipo(ti);
            param.setId(nombreParam.toString());
            param.setLinea(String.valueOf(lastLine));
            param.setColumna(String.valueOf(lastColumn));
            listaTablasSimbolos.get(currentHash).add(param);
            System.out.println(">>> [DEBUG] Parámetro agregado: " + nombreParam.toString() + " en " + currentHash);
        }
    :};


//+++++++++++++++++++++DECLARACIONES Y ASIGNACIONES+++++++++++++++

// VERSIÓN SIMPLIFICADA - DECLARACIONES SEPARADAS
declaracion ::= LET tipo:tipoDato ID:nombreDeclaracion 
{:

    if (esIdExistente(currentHash, nombreDeclaracion.toString())) {
        System.err.printf(" \u001B[31mXXX Error semántico: Variable '%s' ya declarada en scope actual. Línea %d, columna %d.\u001B[0m%n",
            nombreDeclaracion.toString(), lastLine, lastColumn);
        tieneErrores = true;
    } else {
        // Declaración SIN asignación
        NodoToken declaracion = new NodoToken();
        declaracion.setTipo(tipoDato);
        declaracion.setId(nombreDeclaracion.toString());
        declaracion.setValor(null); // Valor vacío por defecto
        declaracion.setLinea(String.valueOf(lastLine));
        declaracion.setColumna(String.valueOf(lastColumn));
        listaTablasSimbolos.get(currentHash).add(declaracion);
        System.out.println(">>> [DEBUG] Variable declarada SIN valor: " + nombreDeclaracion.toString() + " en " + currentHash);
    }
:} 
| LET tipo:tipoDato ID:nombreDeclaracion ASIGN expresion:valorExpr
{:
    if (esIdExistente(currentHash, nombreDeclaracion.toString())) {
        System.err.printf("\u001B[31mXXX Error semántico: Variable '%s' ya declarada en ámbito actual. Línea %d, columna %d.\u001B[0m%n",
            nombreDeclaracion.toString(), lastLine, lastColumn);
        tieneErrores = true;
    } else {
        // Declaración CON asignación
        NodoToken declaracion = new NodoToken();
        declaracion.setTipo(tipoDato);
        declaracion.setId(nombreDeclaracion.toString());

        if (valorExpr != null) {
            String valorReal = "";
            String tempValor = "";
            if (valorExpr instanceof java.util.HashMap) {
                valorReal = ((HashMap)valorExpr).get("valor").toString();
                tempValor = ((HashMap)valorExpr).get("temp").toString();
            } else {
                valorReal = valorExpr.toString();
                tempValor = valorReal;
            }

            //validarAsignacionTipo(tipoDato, valorReal, lastLine, lastColumn);

            declaracion.setValor(valorReal);

            cod3D(nombreDeclaracion + " = " + tempValor);

            System.out.println(">>> [DEBUG] Variable declarada CON valor: " 
                + nombreDeclaracion.toString() + " = " + valorReal + " en " + currentHash);
        } else {
            declaracion.setValor(null);
            System.out.println(">>> [DEBUG] Variable declarada CON valor NULL: " 
                + nombreDeclaracion.toString() + " en " + currentHash);
        }

        declaracion.setLinea(String.valueOf(lastLine));
        declaracion.setColumna(String.valueOf(lastColumn));
        listaTablasSimbolos.get(currentHash).add(declaracion);
    }
:}
;


declaracion_arreglo_entero ::= LET tipo ID:nombreArreglo COR_A ENTERO COR_C ASIGN COR_A lista_elementos_arreglo_entero:elementos COR_C
{:
    // Declaración de arreglo de enteros CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_entero");
    declaracion.setId(nombreArreglo.toString());
    
    StringBuilder elementosStr = new StringBuilder();
    elementosStr.append("[");
    
    if (elementos != null && elementos instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) elementos;
        for (int i = 0; i < elementosLista.size(); i++) {
            if (i > 0) elementosStr.append(", ");
            elementosStr.append(elementosLista.get(i));
        }
        System.out.println(">>> [DEBUG] Arreglo con " + elementosLista.size() + " elementos: " + elementosStr.toString());
    } else {
        elementosStr.append("]");
        System.out.println(">>> [DEBUG] Arreglo sin elementos válidos");
    }
    
    elementosStr.append("]");
    
    declaracion.setValor(elementosStr.toString());
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
    System.out.println(">>> [DEBUG] Arreglo de enteros declarado CON valor: " + nombreArreglo.toString() + " = " + elementosStr.toString() + " en " + currentHash);
:}
;

declaracion_arreglo_char ::= LET tipo ID:nombreArregloChar COR_A ENTERO COR_C ASIGN arreglo_char:valoresChar
{:
    // Declaración de arreglo de chars CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_char");
    declaracion.setId(nombreArregloChar.toString());
    
    if (valoresChar != null) {
        String valorStr = valoresChar.toString();
        declaracion.setValor(valorStr);
        System.out.println(">>> [DEBUG] Arreglo de chars declarado CON valor: " + nombreArregloChar.toString() + " = " + valorStr + " en " + currentHash);
    } else {
        declaracion.setValor("arreglo_char");
        System.out.println(">>> [DEBUG] Arreglo de chars declarado SIN valor específico: " + nombreArregloChar.toString() + " en " + currentHash);
    }
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
:}
;

lista_char ::= CHAR:caracter {: 
    RESULT = caracter.toString();
:}
| lista_char:lista COMA CHAR:caracter {: 

    String listaStr = lista.toString() + ", " + caracter.toString();
    RESULT = listaStr;
:}
;

arreglo_char ::= COR_A lista_char:lista COR_C {: 
    String resultado = "[" + lista.toString() + "]";
    RESULT = resultado;
:};

asignacion ::= ID:nombre ASIGN expresion:valor
{:
    NodoToken variable = buscarID(nombre.toString());
    if (variable != null) {
        if (valor != null) {
            String valorReal = "";
            String tempValor = "";
            if (valor instanceof java.util.HashMap) {
                valorReal = ((HashMap)valor).get("valor").toString();
                tempValor = ((HashMap)valor).get("temp").toString();
            } else {
                valorReal = valor.toString();
                tempValor = valorReal;
            }

            validarAsignacionTipo(variable.getTipo(), valorReal, lastLine, lastColumn);
            cod3D(nombre + " = " + tempValor);
            variable.setValor(valorReal);

            System.out.println(">>> [DEBUG] Asignación: " + nombre + " = " + valorReal);
        } else {
            variable.setValor(null);
        }
    } else {
        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
            nombre.toString(), lastLine, lastColumn);
        tieneErrores = true;
    }
    RESULT = nombre;
:}
| ID:nombre COR_A ENTERO COR_C ASIGN ENTERO:valorArr
{:
    NodoToken variable = buscarID(nombre.toString());
    if (variable != null) {
        variable.setValor("arreglo_entero[" + valorArr + "]");
        cod3D(nombre + "[" + valorArr + "] = " + valorArr);
    } else {
        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
            nombre.toString(), lastLine, lastColumn);
        tieneErrores = true;
    }
        RESULT = nombre;
:}
| ID:nombre COR_A ENTERO COR_C ASIGN CHAR:valorChar
{:
    NodoToken variable = buscarID(nombre.toString());
    if (variable != null) {
        variable.setValor("arreglo_char");
        cod3D(nombre + "[" + valorChar + "] = arreglo_char");
    } else {
        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m%n",
            nombre.toString(), lastLine, lastColumn);
        tieneErrores = true;
    }
    RESULT = nombre;
:}
;


// EXPRESIONES
expresion ::= expresion:e1 AND expresion:e2
    {:
        HashMap<String, String> res = new HashMap<>();
        
        if (e1 != null && e2 != null && !((HashMap)e2).isEmpty()) {
            String temp1 = ((HashMap)e1).get("temp").toString();
            String temp2 = ((HashMap)e2).get("temp").toString();
            String temp = genOperacion3D(temp1, "&&", temp2);
            res.put("temp", temp);
            res.put("valor", "true");
        } else {
            System.err.printf("\u001B[31mXXX Error semántico XXX : Operandos nulos o vacíos en la expresión AND. Línea %d, columna %d.\u001B[0m%n", lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp", "error");
            res.put("valor", "error");
        }
        
        RESULT = res;
    :}
| expresion:e1 OR expresion:e2
    {:
        HashMap<String, String> res = new HashMap<>();
        
        if (e1 != null && e2 != null && !((HashMap)e2).isEmpty()) {
            String temp1 = ((HashMap)e1).get("temp").toString();
            String temp2 = ((HashMap)e2).get("temp").toString();
            String temp = genOperacion3D(temp1, "||", temp2);
            res.put("temp", temp);
            res.put("valor", "true");
        } else {
            System.err.printf("\u001B[31mXXX Error semántico XXX : Operandos nulos o vacíos en la expresión OR. Línea %d, columna %d.\u001B[0m%n", lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp", "error");
            res.put("valor", "error");
        }
        
        RESULT = res;
    :}
| NOT expresion:e
    {:
        HashMap<String,String> res = new HashMap<>();
        String opTemp = "";
        String opValor = "";

        if (e == null) {
            System.err.println(">>> [ERROR] Expresión nula en operador NOT (línea " + lastLine + ")");
            opTemp = "error";
            opValor = "error";
        } else if (e instanceof java.util.HashMap) {
            HashMap tmp = (HashMap)e;
            opTemp = tmp.get("temp") != null ? tmp.get("temp").toString() : "error";
            opValor = tmp.get("valor") != null ? tmp.get("valor").toString() : "true";
        } else {
            opTemp = e.toString();
            opValor = e.toString();
        }

        String temp = nuevaTempInt();
        cod3D(temp + " = !" + opTemp);
        res.put("temp", temp);
        res.put("valor", "!" + opValor);
        RESULT = res;
    :}

| expresion_arit:e1 op_rel:op expresion_arit:e2
    {:
        HashMap<String, String> res = new HashMap<>();
        System.out.println(">>> [DEBUG] Evaluando expresión relacional con operadores: " + op.toString());
        if (e1 != null && e2 != null) {
            String val1 = ((HashMap)e1).get("valor").toString();
            String val2 = ((HashMap)e2).get("valor").toString();
            String tipo1 = obtenerTipoExpresion(val1);
            String tipo2 = obtenerTipoExpresion(val2);
            

            if (sonTiposCompatibles(tipo1, tipo2)) { 
                String t1 = ((HashMap)e1).get("temp").toString();
                String t2 = ((HashMap)e2).get("temp").toString();
                String temp = genOperacion3D(t1, op.toString(), t2);
                res.put("temp", temp);
                res.put("valor", "true");
                RESULT = res;
            } else {
                System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en expresión relacional. Línea %d, columna %d.\u001B[0m%n",
                    tipo1, tipo2, lastLine, lastColumn);
                tieneErrores = true;
                RESULT = null;
            }
        } else {
            System.err.printf("\u001B[31mXXX Error semántico XXX : Expresiones nulas en operación relacional. Línea %d, columna %d.\u001B[0m%n", lastLine, lastColumn);
            tieneErrores = true;
            RESULT = null;
        }
    :}

| expresion_arit:e {: RESULT = e; :}
;

// EXPRESIONES ARITMETICAS
expresion_arit ::= expresion_arit:e1 MAS termino:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        if (sonTiposCompatibles(obtenerTipoExpresion(v1), obtenerTipoExpresion(v2))) {

            System.out.println(v1 + " + " + v2);            
            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {

                String temp = genOperacion3D(t1, "+", t2);
                res.put("temp", temp);
                res.put("valor", v1+"+"+v2);
            }
        } else {
            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en suma. Línea %d, columna %d.\u001B[0m%n",
                obtenerTipoExpresion(v1), obtenerTipoExpresion(v2), lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
        }

        RESULT = res;
    :}
| expresion_arit:e1 MENOS termino:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        if (sonTiposCompatibles(obtenerTipoExpresion(v1), obtenerTipoExpresion(v2))) {

            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {

                String temp = genOperacion3D(t1, "-", t2);
                res.put("temp", temp);
                res.put("valor", v1+"-"+v2);
            }
        } else {
            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en resta. Línea %d, columna %d.\u001B[0m%n",
                obtenerTipoExpresion(v1), obtenerTipoExpresion(v2), lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
        }
        RESULT = res;
    :}
| termino:t {: RESULT = t; :}
;

// TERMINOS
termino ::= termino:e1 POR factor:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        String tt1 = obtenerTipoExpresion(v1);
        String tt2 = obtenerTipoExpresion(v2);

        if (!sonTiposCompatibles(tt1, tt2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en multiplicación. Línea %d, columna %d.\u001B[0m%n",
                tt1, tt2, lastLine, lastColumn);
        } else {

            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {
                String temp = genOperacion3D(t1, "*", t2);
                res.put("temp", temp);
                res.put("valor", v1 + "*" + v2);
            }
        }
        RESULT = res;
    :}
| termino:e1 DIV factor:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        String tt1 = obtenerTipoExpresion(v1);
        String tt2 = obtenerTipoExpresion(v2);

        if (!sonTiposCompatibles(tt1, tt2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: Tipos incompatibles '%s' y '%s' en división. Línea %d, columna %d.\u001B[0m%n",
                tt1, tt2, lastLine, lastColumn);
        }
        else if (esCeroLiteral(v2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: División por cero (literal 0/0.0). Línea %d, columna %d.\u001B[0m%n",
                lastLine, lastColumn);
        } else {
            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {
                String temp = genOperacion3D(t1, "/", t2);
                res.put("temp", temp);
                res.put("valor", v1 + "/" + v2);
            }
        }
        RESULT = res;
    :}
| termino:e1 DIV_ENT factor:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        String tt1 = obtenerTipoExpresion(v1);
        String tt2 = obtenerTipoExpresion(v2);

        if (!sonAmbosEnteros(tt1, tt2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: DIV_ENT requiere enteros (recibido '%s' y '%s'). Línea %d, columna %d.\u001B[0m%n",
                tt1, tt2, lastLine, lastColumn);
        }
        else if (esCeroLiteral(v2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: División entera por cero. Línea %d, columna %d.\u001B[0m%n",
                lastLine, lastColumn);
        } else {
            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {
                String temp = genOperacion3D(t1, "//", t2); 
                res.put("temp", temp);
                res.put("valor", v1 + "//" + v2);
            }
        }
        RESULT = res;
    :}
| termino:e1 MOD factor:e2
    {:
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();
        String t1 = ((HashMap)e1).get("temp").toString();
        String t2 = ((HashMap)e2).get("temp").toString();

        String tt1 = obtenerTipoExpresion(v1);
        String tt2 = obtenerTipoExpresion(v2);

        if (!sonAmbosEnteros(tt1, tt2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: MOD requiere enteros (recibido '%s' y '%s'). Línea %d, columna %d.\u001B[0m%n",
                tt1, tt2, lastLine, lastColumn);
        }
        else if (esCeroLiteral(v2)) {
            tieneErrores = true;
            res.put("temp","error");
            res.put("valor","error");
            System.err.printf("\u001B[31mXXX Error semántico: Módulo por cero. Línea %d, columna %d.\u001B[0m%n",
                lastLine, lastColumn);
        } else {
            NodoToken var1 = buscarID(v1);
            NodoToken var2 = buscarID(v2);

            if (var1 != null && var1.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v1, lastLine, lastColumn);
                tieneErrores = true;
            } else if (var2 != null && var2.getValor() == null) {
                System.err.printf("\u001B[31mXXX Error semántico XXX : La variable '%s' no tiene valor asignado. Línea %d, columna %d.\u001B[0m%n", v2, lastLine, lastColumn);
                tieneErrores = true;
            } else {
                String temp = genOperacion3D(t1, "%", t2);
                res.put("temp", temp);
                res.put("valor", v1 + "%" + v2);
            }
        }
        RESULT = res;
    :}
| factor:f {: RESULT = f; :}
;


// FACTORES
factor ::= potencia:e1 POT potencia:e2
    {:
        // Verificar que ambos factores sean números
        HashMap<String,String> res = new HashMap<>();
        String v1 = ((HashMap)e1).get("valor").toString();
        String v2 = ((HashMap)e2).get("valor").toString();

        if (!(v1.matches("^-?\\d+$") || v1.matches("^-?\\d*\\.\\d+$"))) {
            System.err.printf("\u001B[31mXXX Error semántico: Operando izquierdo '%s' no es numérico en operación de potencia. Línea %d, columna %d.\u001B[0m%n",
                v1, lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp", "error");
            res.put("valor", "error");
        } else if (!(v2.matches("^-?\\d+$") || v2.matches("^-?\\d*\\.\\d+$"))) {
            System.err.printf("\u001B[31mXXX Error semántico: Operando derecho '%s' no es numérico en operación de potencia. Línea %d, columna %d.\u001B[0m%n",
                v2, lastLine, lastColumn);
            tieneErrores = true;
            res.put("temp", "error");
            res.put("valor", "error");
        } else {
            String t1 = ((HashMap)e1).get("temp").toString();
            String t2 = ((HashMap)e2).get("temp").toString();
            String temp = genOperacion3D(t1, "^", t2);
            res.put("temp", temp);
            res.put("valor", v1 + "^" + v2); 
        }
        RESULT = res;
    :}
| potencia:p {: RESULT = p; :}
;


// POTENCIAS
potencia ::= PAR_A expresion:e PAR_C {: RESULT = e; :}
    | operando:o {: RESULT = o; :}
;
    
//UN OPERANDO ES LA FORMA MÁS SENCILLA DE UNA OPERACIÓN
operando ::= ENTERO:a {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempInt();
    cod3D(temp + " = " + a);
    res.put("temp", temp);
    res.put("valor", a.toString());
    RESULT = res;
:}
| FLOTANTE:f {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempFloat();
    cod3D(temp + " = " + f);
    res.put("temp", temp);
    res.put("valor", f.toString());
    RESULT = res;
:}
| TRUE1 {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempInt();
    cod3D(temp + " = 1");
    res.put("temp", temp);
    res.put("valor", "true");
    RESULT = res;
:}
| FALSE1 {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempInt();
    cod3D(temp + " = 0");
    res.put("temp", temp);
    res.put("valor", "false");
    RESULT = res;
:}
| CHAR:c {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempInt();
    cod3D(temp + " = " + c);
    res.put("temp", temp);
    res.put("valor", c.toString());
    RESULT = res;
:}
| CADENA:s {:
    HashMap<String,String> res = new HashMap<>();
    String temp = nuevaTempInt();
    cod3D(temp + " = " + s);
    res.put("temp", temp);
    res.put("valor", s.toString());
    RESULT = res;
:}
| ID:id {:
    HashMap<String,String> res = new HashMap<>();
    NodoToken var = buscarID(id.toString());
    if (var == null) {
        System.err.printf("\u001B[31mXXX Error semántico: variable '%s' no declarada.\u001B[0m%n", id.toString());
        tieneErrores = true;
        res.put("temp","error");
        res.put("valor","error");
    } else {
        String temp = nuevaTempInt();
        cod3D(temp + " = " + id);
        res.put("temp", temp);
        res.put("valor", id.toString());
    }
    RESULT = res;
:}
| elem_arr:e {:
    HashMap<String,String> res = new HashMap<>();
    if (e != null) {
        String temp = nuevaTempInt();
        cod3D(temp + " = " + e.toString());
        res.put("temp", temp);
        res.put("valor", e.toString());
    } else {
        res.put("temp","error");
        res.put("valor","error");
    }
    RESULT = res;
:}
| MENOS operando:op {:
    HashMap<String,String> res = new HashMap<>();
    if (op != null && !((HashMap)op).get("temp").equals("error")) {
        String t = ((HashMap)op).get("temp").toString();
        String v = ((HashMap)op).get("valor").toString();
        String temp = nuevaTempInt();
        cod3D(temp + " = -" + t);
        res.put("temp", temp);
        res.put("valor", "-" + v);
    } else {
        res.put("temp","error");
        res.put("valor","error");
    }
    RESULT = res;
:}
| llamada_funcion:llamada {:
    HashMap<String,String> res = new HashMap<>();
    if (llamada != null) {
        String temp = nuevaTempInt();
        cod3D(temp + " = " + llamada.toString());
        res.put("temp", temp);
        res.put("valor", llamada.toString());
    } else {
        res.put("temp","error");
        res.put("valor","error");
    }
    RESULT = res;
:}
| incrementar:inc {:
    HashMap<String,String> res = new HashMap<>();
    if (inc != null) {
        String temp = nuevaTempInt();
        cod3D(temp + " = " + inc.toString());
        res.put("temp", temp);
        res.put("valor", inc.toString());
    } else {
        res.put("temp","error");
        res.put("valor","error");
    }
    RESULT = res;
:}
| decrementar:dec {:
    HashMap<String,String> res = new HashMap<>();
    if (dec != null) {
        String temp = nuevaTempInt();
        cod3D(temp + " = " + dec.toString());
        res.put("temp", temp);
        res.put("valor", dec.toString());
    } else {
        res.put("temp","error");
        res.put("valor","error");
    }
    RESULT = res;
:}
;


// OPERADORES RELACIONALES
op_rel ::= MAYOR    {: RESULT = ">";  :}
    | MENOR        {: RESULT = "<";  :}
    | MAY_IGU      {: RESULT = ">="; :}
    | MEN_IGU      {: RESULT = "<="; :}
    | IGUAL        {: RESULT = "=="; :}
    | DIF          {: RESULT = "!="; :}
    ;

// ESTRUCTURAS DE CONTROL 

// TO-DO: arbol sintáctico para condicionales y bucles

condicional ::=
    DECIDE OF
    {:
        // AQUI SE CREA EL SCOPE PARA EL BLOQUE DECIDE
        contadorDecide++;
        String decideScope = currentHash + "_DECIDE_" + contadorDecide;
        crearSubAmbito(decideScope);
        System.out.println(">>> [DEBUG] Inicia ámbito DECIDE: " + decideScope);
        
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = decideScope;

        RESULT = anteriorScope;
    :}
    lista_casos
    cond_else_opt
    END DECIDE
    {:
        // recuperar el scope en el que estaba antes
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito DECIDE, regresando a: " + currentHash);
    :}
    ;

lista_casos ::= caso
              | lista_casos caso
              ;

caso ::=
    PAR_A expresion PAR_C FLECHA
    {:
        // SCOPE POR CADA CASO
        contadorCase++;
        String caseScope = currentHash + "_CASE_" + contadorCase;
        crearSubAmbito(caseScope);
        System.out.println(">>> [DEBUG] Inicia ámbito CASE: " + caseScope);

        String anteriorScope = currentHash;
        currentHash = caseScope;
        RESULT = anteriorScope;
    :}
    bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito CASE, regresando a: " + currentHash);
    :}
    ;

cond_else_opt ::=
      /* vacío */
    | ELSE FLECHA
    {:
        contadorElse++;
        String elseScope = currentHash + "_ELSE_" + contadorElse;
        crearSubAmbito(elseScope);
        System.out.println(">>> [DEBUG] Inicia ámbito ELSE: " + elseScope);

        String anteriorScope = currentHash;
        currentHash = elseScope;
        RESULT = anteriorScope;
    :}
      bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito ELSE, regresando a: " + currentHash);
    :}
    ;

bucle_loop ::=
    LOOP
    {:
        // Crear scope de tabla de símbolos 
        contadorLoop++;
        String loopScope = currentHash + "_LOOP_" + contadorLoop;
        crearSubAmbito(loopScope);
        cod3D("\n" + currentHash + "_loop_" + contadorLoop + ":");


        System.out.println(">>> [DEBUG] Inicia ámbito LOOP: " + loopScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = loopScope;

        // Codigo intermedio

        RESULT = anteriorScope;
    :}
    lista_sentencias
    EXIT WHEN expresion:e1 FIN_E
    {: 
        // Codigo intermedio NO HAY VALIDACION SEMANTICA
        cod3D("if " + e1 + " goto " + currentHash + "_endloop_" + contadorLoop);
    :}
    END LOOP FIN_E
    {:
        // Codigo intermedio
        cod3D("goto " + currentHash + "_loop_" + contadorLoop);
        cod3D(currentHash + "_endloop_" + contadorLoop + ":");

        // Restaurar el scope previo
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito LOOP, regresando a: " + currentHash);
    :}
    ;

bucle_for ::=
    FOR1
    asignacion:e
    step ENTERO:valor
    direccion:dir expresion:limite
    {:

        contadorFor++;
        String forScope = currentHash + "_FOR_" + contadorFor;
        cod3D(forScope + ":");
        String temporalContador = nuevaTempInt();
        String temporalLimite = nuevaTempInt();
        String temporalValidacion = nuevaTempInt();
        cod3D(temporalContador + " = " + e);
        cod3D(temporalLimite + " = " + limite);
        int numeroStep = Integer.parseInt(valor.toString());
        if(numeroStep > 0){
            if (dir.equals("downto")) {
                cod3D(temporalValidacion + " = " + temporalContador + " < " + temporalLimite);
            } else {
                cod3D(temporalValidacion + " = " + temporalContador + " > " + temporalLimite);
            }
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       El valor de STEP debe ser mayor que 0. Línea %d, columna %d.\u001B[0m %n", lastLine, lastColumn);
            tieneErrores = true;
        }    
        
        crearSubAmbito(forScope);
        cod3D("if " + temporalValidacion + " goto " + forScope + "_endfor_" + contadorFor);
        if (dir.equals("downto")) {
            cod3D(e + " = " + temporalContador + " - " + valor);
        } else {
            cod3D(e + " = " + temporalContador + " + " + valor);
        }
        System.out.println(">>> [DEBUG] Inicia ámbito FOR: " + forScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = forScope;
        RESULT = anteriorScope;
        
    :}
        DO bloque
    {:
        String forFinal = currentHash + "_endfor_" + contadorFor;
        cod3D("goto " +currentHash);
        cod3D(forFinal+ ":");
        // Recupera el scope anterior
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito FOR, regresando a: " + currentHash);
    :}
    ;

step ::= /* vacío */
       | STEP
       ;

direccion ::= TO:to {: RESULT = to.toString(); :}
            | DOWNTO:downto {: RESULT = downto.toString(); :}
            ;

//++++++++++++++++++++++++++++++++ARREGLOS+++++++++++++++++++++++++++++

lista_elementos_arreglo_entero ::= ENTERO:entero {: 
    // Primer elemento
    ArrayList<String> elementos = new ArrayList<>();
    elementos.add(entero.toString());
    RESULT = elementos;
    System.out.println(">>> [DEBUG] Primer elemento del arreglo: " + entero);
:}
| lista_elementos_arreglo_entero:lista COMA ENTERO:entero {: 
    // Agregar elemento a la lista existente
    if (lista != null && lista instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) lista;
        elementosLista.add(entero.toString());
        RESULT = elementosLista;
        System.out.println(">>> [DEBUG] Agregando elemento al arreglo: " + entero + ", total: " + elementosLista.size());
    } else {
        // Si por alguna razón la lista no es válida, crear una nueva
        ArrayList<String> elementos = new ArrayList<>();
        elementos.add(entero.toString());
        RESULT = elementos;
        System.out.println(">>> [DEBUG] Creando nueva lista con elemento: " + entero);
    }
:}
;
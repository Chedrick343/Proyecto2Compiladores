package salchichon_script;

import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.ArrayList;
import java.io.FileWriter;

// PARSER
parser code
{:
    public class NodoToken{
        String tipo;
        String id;
        String valor;
        String linea;
        String columna;
        public NodoToken() {
        }

        public String getTipo() {
            return tipo;
        }

        public void setTipo(String tipo) {
            this.tipo = tipo;
        }
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getValor() {
            return valor;
        }

        public void setValor(String valor) {
            this.valor = valor;
        }

        public String getLinea() {
            return linea;
        }

        public void setLinea(String linea) {
            this.linea = linea;
        }

        public String getColumna() {
            return columna;
        }

        public void setColumna(String columna) {
            this.columna = columna;
        }
        @Override
        public String toString() {
            return "NodoToken \n{\n" +
                " tipo = " + tipo + '\n' +
                " id = " + id + '\n' +
                " valor = " + valor + '\n' +
                " linea = " + linea + '\n' +
                " columna = " + columna + '\n' +
            '}';
        }
    }

    HashMap<String, ArrayList<NodoToken>> listaTablasSimbolos = new HashMap<>();
    String currentHash;
    String globalHash = "global1TS";
    int contadorLoop = 0;
    int contadorFor = 0;
    int contadorDecide = 0;
    int contadorCase = 0;
    int contadorElse = 0;

    public void inicarTS() {
        listaTablasSimbolos.put(globalHash, new ArrayList<>());
        currentHash = globalHash;

        NodoToken printFunc = new NodoToken();
        printFunc.setTipo("funcion_sistema");
        printFunc.setId("imprimir");
        printFunc.setValor("void");
        printFunc.setLinea("0");
        printFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(printFunc);

        NodoToken readFunc = new NodoToken();
        readFunc.setTipo("funcion_sistema");
        readFunc.setId("leer");
        readFunc.setValor("string");
        readFunc.setLinea("0");
        readFunc.setColumna("0");
        listaTablasSimbolos.get(globalHash).add(readFunc);
    }

    public void imprimirTablasSimbolos(){
        try{
            FileWriter writer = new FileWriter("tokens.txt");
            for(String key: listaTablasSimbolos.keySet()){
                //System.out.println("------------------Tabla de simbolo : " + key);
                writer.write("Tabla de simbolos: " + key + "\n");
                writer.write("********Valores*********** \n");
                //System.out.println("********Valores*********** ");
                for(NodoToken item : listaTablasSimbolos.get(key)){
                    //System.out.println(item.toString());
                    writer.write(item.toString() + "\n");
                }
                //System.out.println("------------------Fin tabla de simbolos : " + key);
                writer.write("------------------Fin tabla de simbolos : " + key + "\n\n");
            }
            writer.close();
        }catch(Exception e){
            System.out.println("Error al escribir el archivo de tokens: " + e.getMessage());
        }
    }
    
    public String getTipo(ArrayList<NodoToken> tabla, String id){
        String tipo = "";
        for(NodoToken token : tabla){
            if(id.equals(token.getValor())){
                tipo = token.getTipo();
            }
        }
        System.out.println("tipo: "+tipo);
        return tipo;
    }

    public NodoToken buscarID(String id){
        System.out.println(">>> [DEBUG] Buscando ID: '" + id + "' en ámbito: " + currentHash);
        
        if(listaTablasSimbolos.containsKey(currentHash)){
            for(NodoToken tok : listaTablasSimbolos.get(currentHash)){
                if(tok.getId().equals(id)) {
                    System.out.println(">>> [DEBUG] Encontrado en ámbito actual: " + tok.getId() + " = " + tok.getValor());
                    return tok;
                }
            }
        }
        
        for(NodoToken tok : listaTablasSimbolos.get(globalHash)){
            if(tok.getId().equals(id)) {
                System.out.println(">>> [DEBUG] Encontrado en ámbito global: " + tok.getId() + " = " + tok.getValor());
                return tok;
            }
        }
        
        System.out.println(">>> [DEBUG] NO encontrado: " + id);
        return null;
    }

    /**
     * Crea un nuevo scope (tabla de símbolos) heredando las variables visibles del scope su[perior.
     * @param nombreScope Nombre único del nuevo ámbito.
     */
    public void crearSubAmbito(String nombreScope) {
        ArrayList<NodoToken> nuevo = new ArrayList<>();

        // Copiar los simbolos anteriores al nuevo scope
        if (listaTablasSimbolos.containsKey(currentHash)) {
            for (NodoToken tok : listaTablasSimbolos.get(currentHash)) {
                NodoToken copia = new NodoToken();
                copia.setTipo(tok.getTipo());
                copia.setId(tok.getId());
                copia.setValor(tok.getValor());
                copia.setLinea(tok.getLinea());
                copia.setColumna(tok.getColumna());
                nuevo.add(copia);
            }
        }

        // Registrar el nuevo scope con los simbolos heredados
        listaTablasSimbolos.put(nombreScope, nuevo);

        System.out.println(">>> [DEBUG] Nuevo ámbito creado: " + nombreScope + " heredando de " + currentHash);
    }


    // TO-DO: GENERACION DE CODIGO INTERMEDIO: CODIGO 3 DIRECCIONES 
    StringBuilder codigoIntermedio = new StringBuilder();
    int tempCont = 0;
    int floatTempCont = 0;
    int labelCont = 0;

    // para enteros
    String nuevaTempInt() {
        return "t" + (++tempCont);
    }

    // para flotantes
    String nuevaTempFloat() {
        return "f" + (++floatTempCont);
    }

    void cod3D(String codigo) {
        codigoIntermedio.append(codigo).append("\n");
        System.out.println(">>> [3AC] " + codigo);
    }





    // ==================== Validacion semantica ====================

    public void validarAsignacionTipo(String tipoEsperado, String valorAsignado, int linea, int columna) {
        if (valorAsignado == null || tipoEsperado == null) return;

        switch (tipoEsperado) {
            case "int":
                try {
                    Integer.parseInt(valorAsignado);
                } catch (NumberFormatException e) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'int'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "float":
                try {
                    Float.parseFloat(valorAsignado);
                } catch (NumberFormatException e) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'float'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "boolean":
                if (!(valorAsignado.equals("true") || valorAsignado.equals("false"))) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'boolean'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "char":
                if (valorAsignado.length() != 3 || valorAsignado.charAt(0) != '\'' || valorAsignado.charAt(2) != '\'') {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'char'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            case "string":
                if (!valorAsignado.startsWith("\"") || !valorAsignado.endsWith("\"")) {
                    System.err.printf("\u001B[31m XXX Error semántico XXX : Valor '%s' no válido para tipo 'string'. Línea %d, columna %d.\u001B[0m%n",
                        valorAsignado, linea, columna);
                    tieneErrores = true;
                }
                break;

            default:
                System.err.printf("\u001B[33m [ADVERTENCIA] Tipo '%s' no reconocido para validación semántica.\u001B[0m%n", tipoEsperado);
                break;
        }
    }


    /** Devuelve el tipo de una expresion o valor */
    public String obtenerTipoExpresion(Object valor) {
        if (valor == null) return "desconocido";
        String v = valor.toString();

        if (v.startsWith("f")) return "float"; // temporal de float
        if (v.startsWith("t")) return "int";   // temporal de int
        if (v.matches("^-?\\d+$")) return "int";
        if (v.matches("^-?\\d*\\.\\d+$")) return "float";
        if (v.equals("true") || v.equals("false")) return "boolean";
        if (v.startsWith("\"") && v.endsWith("\"")) return "string";
        if (v.startsWith("'") && v.endsWith("'") && v.length() == 3) return "char";
        
        // Buscar en tabla de simbolos
        NodoToken tok = buscarID(v);
        if (tok != null) return tok.getTipo();

        return "desconocido";
    }

    /** Valida si dos tipos son compatibles para operaciones aritmeticas */
    public boolean sonTiposCompatibles(String t1, String t2) {
        if (t1.equals("int") && t2.equals("int")) return true;
        if (t1.equals("float") && t2.equals("float")) return true;
        if ((t1.equals("int") && t2.equals("float")) || (t1.equals("float") && t2.equals("int"))) return true;
        if (t1.equals("string") && t2.equals("string")) return true; // concatenacion
        if (t1.equals("char") && t2.equals("char")) return true;     // concatenacion de chars
        return false;
    }



    // ==================== Manejo de errores ====================

    public boolean tieneErrores = false;

    // Para recordar última posición válida
    private int lastLine = 1;
    private int lastColumn = 1;

    // Guardar última posición válida después de cada token leído
    @Override
    public Symbol scan() throws Exception {
        Symbol sym = super.scan();
        if (sym != null) {
            if (sym.left >= 0) lastLine = sym.left + 1;
            if (sym.right >= 0) lastColumn = sym.right + 1;
        }
        return sym;
    }

    // Errores recuperables
    @Override
    public void syntax_error(Symbol s) {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m XXX Error sintáctico recuperable XXX :       Token '%s' en línea %d, columna %d.\u001B[0m %n", lexema, linea, columna);
    }

    // Errores no recuperables
    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        tieneErrores = true; 
        String lexema = (s != null && s.value != null) ? s.value.toString() : "EOF o símbolo desconocido";
        int linea = (s != null && s.left >= 0) ? s.left + 1 : lastLine;
        int columna = (s != null && s.right >= 0) ? s.right + 1 : lastColumn;

        System.err.printf("\u001B[31m     XXX Error sintáctico crítico XXX :       Token '%s' en línea %d, columna %d. \u001B[0m %n", lexema, linea, columna);
    }
:}

action code
{:
    // Codigo de usuario - fase de analisis
    String tmp="";
:}

// TERMINALES
terminal PAR_A, PAR_C, BLO_A, BLO_C, COMA, FLECHA, FIN_E, ASIGN, COR_A, COR_C, COMILLA_SIMP, CADENA_CHAR;
terminal MAS, MENOS, POR, DIV, DIV_ENT, MOD, POT;
terminal AND, OR, NOT;
terminal INC, DEC;
terminal MAYOR, MENOR, MAY_IGU, MEN_IGU, IGUAL, DIF;
terminal INT1, CHAR1, STR1, FLOAT1, BOOL1, LET, VOID, TRUE1, FALSE1, DECIDE;
terminal OF, ELSE, END, LOOP, EXIT, WHEN, FOR1, STEP, TO, DOWNTO, DO;
terminal RETURN, BREAK;
terminal INIT;

terminal ENTERO, FLOTANTE, CHAR, ID;
terminal IMPRIMIR, LEER, MAIN, CADENA;

// NO TERMINALES
non terminal Object program;
non terminal main_funcion, elemento_global, lista_global;
non terminal String tipo, tipo_funcion;
non terminal declaracion;
non terminal bloque, lista_sentencias, lista_sentencias_opt, sentencia, expr_opc, llamada_funcion, parametros_llamada, imprimir, leer;
non terminal funcion, parametros_opt, lista_parametros, parametro;
non terminal asignacion, asignacion_dec;
non terminal expresion;
non terminal expresion_arit, termino, factor, potencia, operando, elem_arr;
non terminal op_rel, incrementar, decrementar;
non terminal condicional, lista_casos, caso, cond_else_opt, bucle_loop, bucle_for, step, direccion;
non terminal lista_elementos_arreglo_entero, lista_char, diferente_asignacion, arreglo_char, declaracion_arreglo_entero, declaracion_arreglo_char, asignacion_arreglo_entero, asignacion_arreglo_char; 
non terminal declara_func, declara_main_func;

// PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left IGUAL, DIF;
precedence left MAYOR, MENOR, MAY_IGU, MEN_IGU;
precedence left MAS, MENOS;
precedence left POR, DIV, DIV_ENT, MOD;
precedence right POT;
precedence right NOT;

// PRODUCCIONES

start with program;

program ::= {:  
                System.out.println("generando tabla de símbolos");
                inicarTS();
            :}
                lista_global main_funcion lista_global
            {:
                imprimirTablasSimbolos();

                // Guardar codigo 3d a archivo
                try {
                    java.nio.file.Files.write(
                        java.nio.file.Paths.get("intermedio.txt"),
                        codigoIntermedio.toString().getBytes()
                    );
                    System.out.println(">>> [3AC] Código intermedio guardado en intermedio.txt");
                } catch (Exception e) {
                    System.err.println("MAL" + e.getMessage());
                }
                System.out.println("fin de ejecución");

            :}
            ;
            
lista_global ::= elemento_global lista_global
    | /* vacío */
    ;

elemento_global ::= sentencia
    | funcion
    {: System.out.println("Fin variables globales"); :}
    ;

main_funcion ::= declara_main_func PAR_A PAR_C bloque
    | declara_main_func bloque
    | declara_main_func error
    ;

declara_main_func ::= INIT VOID:tipo MAIN:main
{:
    NodoToken func = new NodoToken();
    func.setId(main.toString());
    func.setTipo(tipo.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + main.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función main creada: " + currentHash);

    // CODIGO INTERMEDIO
    cod3D("\n" + main + ":");
:};

// ======== DECLARACIÓN DE VARIABLES ========
tipo ::= INT1 {: RESULT = "int"; :}
    | STR1 {: RESULT = "string"; :}
    | FLOAT1 {: RESULT = "float"; :}
    | BOOL1 {: RESULT = "boolean"; :}
    | CHAR1 {: RESULT = "char"; :}
    ;

tipo_funcion ::= tipo:t {: RESULT = t; :}
    | VOID {: RESULT = "void"; :}
    ;

//+++++++++++++++++++++BLOQUE++++++++++++++++++++++++++++++++++

bloque ::= BLO_A lista_sentencias_opt BLO_C
         | BLO_A error BLO_C
         ;

lista_sentencias_opt ::= /* vacío */
                     | lista_sentencias
                     ;

lista_sentencias ::= sentencia
                  | lista_sentencias sentencia
                  ;
                  
sentencia ::= declaracion FIN_E
    | declaracion_arreglo_entero FIN_E
    | declaracion_arreglo_char FIN_E
    | asignacion_arreglo_entero FIN_E
    | asignacion_arreglo_char FIN_E
    | asignacion FIN_E
    | llamada_funcion FIN_E
    | imprimir FIN_E
    | leer FIN_E
    | RETURN expr_opc FIN_E
    | BREAK FIN_E
    | incrementar FIN_E
    | decrementar FIN_E
    | condicional FIN_E
    | bucle_loop 
    | bucle_for
    | error FIN_E
    ;

incrementar ::= ID INC;
decrementar ::= ID DEC;

expr_opc ::=
      expresion
    | /* ε */
    ;

llamada_funcion ::= ID PAR_A parametros_llamada PAR_C;

parametros_llamada ::= expresion
                        | expresion COMA parametros_llamada
                        |
                        ;

imprimir ::= IMPRIMIR PAR_A expresion:e PAR_C
{:
    NodoToken imp = new NodoToken();
    imp.setTipo("llamada_funcion_sistema");
    imp.setId("imprimir");
    imp.setValor(e != null ? e.toString() : "");
    imp.setLinea(String.valueOf(lastLine));
    imp.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(imp);
    System.out.println(">>> [DEBUG] Uso de imprimir() en " + currentHash + " con valor: " + imp.getValor());
:};

leer ::= LEER PAR_A PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("entrada_usuario");
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash);
:}
| LEER PAR_A ID:var PAR_C
{:
    NodoToken leerNode = new NodoToken();
    leerNode.setTipo("llamada_funcion_sistema");
    leerNode.setId("leer");
    leerNode.setValor("asigna_a:" + var.toString());
    leerNode.setLinea(String.valueOf(lastLine));
    leerNode.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(leerNode);
    System.out.println(">>> [DEBUG] Uso de leer() en " + currentHash + ", asignando a " + var);
:};


//+++++++++++++++++++++FUNCIONES++++++++++++++++++++++++++++++++

funcion ::= declara_func PAR_A parametros_opt:params PAR_C
             bloque
             {:
                currentHash = globalHash;
                System.out.println(">> [TS] Regresando a tabla global.");
            :}
          | declara_func PAR_A parametros_opt PAR_C error
          ;

declara_func::= tipo_funcion:tipoFun ID:nombreFun
{:
    NodoToken func = new NodoToken();
    func.setId(nombreFun.toString());
    func.setTipo(tipoFun.toString());
    func.setLinea(String.valueOf(lastLine));
    func.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(globalHash).add(func);

    currentHash = "TS_FUNC_" + nombreFun.toString();
    listaTablasSimbolos.put(currentHash, new ArrayList<>());
    System.out.println(">>> [DEBUG] Función creada: " + currentHash);


    // CODIGO INTERMEDIO
    cod3D("\n" + nombreFun + ":");
:};

parametros_opt ::= lista_parametros
                 | // VACIO
                 ;

lista_parametros ::= parametro
                  | lista_parametros COMA parametro
                  ;

parametro ::= tipo:ti ID:nombreParam
    {:
        NodoToken param = new NodoToken();
        param.setTipo(ti);
        param.setId(nombreParam.toString());
        param.setLinea(String.valueOf(lastLine));
        param.setColumna(String.valueOf(lastColumn));
        listaTablasSimbolos.get(currentHash).add(param);
        System.out.println(">>> [DEBUG] Parámetro agregado: " + nombreParam.toString() + " en " + currentHash);
    :};

//+++++++++++++++++++++DECLARACIONES Y ASIGNACIONES+++++++++++++++

// VERSIÓN SIMPLIFICADA - DECLARACIONES SEPARADAS
declaracion ::= LET tipo:tipoDato ID:nombreDeclaracion 
{:
    // Declaración SIN asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo(tipoDato);
    declaracion.setId(nombreDeclaracion.toString());
    declaracion.setValor(""); // Valor vacío por defecto
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
    System.out.println(">>> [DEBUG] Variable declarada SIN valor: " + nombreDeclaracion.toString() + " en " + currentHash);
:} 
| LET tipo:tipoDato ID:nombreDeclaracion ASIGN expresion:valorExpr
{:
    // Declaración CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo(tipoDato);
    declaracion.setId(nombreDeclaracion.toString());
    
    if (valorExpr != null) {
        String valorStr = valorExpr.toString();

        validarAsignacionTipo(tipoDato, valorStr, lastLine, lastColumn);

        declaracion.setValor(valorStr);
        System.out.println(">>> [DEBUG] Variable declarada CON valor: " + nombreDeclaracion.toString() + " = " + valorStr + " en " + currentHash);
    } else {
        declaracion.setValor("");
        System.out.println(">>> [DEBUG] Variable declarada CON valor NULL: " + nombreDeclaracion.toString() + " en " + currentHash);
    }
        // EYDEN: POR QUE HAY UN ELSE AQUI???

    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
:}
;
declaracion_arreglo_entero ::= LET tipo ID:nombreArreglo COR_A ENTERO COR_C ASIGN COR_A lista_elementos_arreglo_entero:elementos COR_C
{:
    // Declaración de arreglo de enteros CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_entero");
    declaracion.setId(nombreArreglo.toString());
    
    StringBuilder elementosStr = new StringBuilder();
    elementosStr.append("[");
    
    if (elementos != null && elementos instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) elementos;
        for (int i = 0; i < elementosLista.size(); i++) {
            if (i > 0) elementosStr.append(", ");
            elementosStr.append(elementosLista.get(i));
        }
        System.out.println(">>> [DEBUG] Arreglo con " + elementosLista.size() + " elementos: " + elementosStr.toString());
    } else {
        elementosStr.append("]");
        System.out.println(">>> [DEBUG] Arreglo sin elementos válidos");
    }
    
    elementosStr.append("]");
    
    declaracion.setValor(elementosStr.toString());
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
    System.out.println(">>> [DEBUG] Arreglo de enteros declarado CON valor: " + nombreArreglo.toString() + " = " + elementosStr.toString() + " en " + currentHash);
:}
;

declaracion_arreglo_char ::= LET tipo ID:nombreArregloChar COR_A ENTERO COR_C ASIGN arreglo_char:valoresChar
{:
    // Declaración de arreglo de chars CON asignación
    NodoToken declaracion = new NodoToken();
    declaracion.setTipo("arreglo_char");
    declaracion.setId(nombreArregloChar.toString());
    
    if (valoresChar != null) {
        String valorStr = valoresChar.toString();
        declaracion.setValor(valorStr);
        System.out.println(">>> [DEBUG] Arreglo de chars declarado CON valor: " + nombreArregloChar.toString() + " = " + valorStr + " en " + currentHash);
    } else {
        declaracion.setValor("arreglo_char");
        System.out.println(">>> [DEBUG] Arreglo de chars declarado SIN valor específico: " + nombreArregloChar.toString() + " en " + currentHash);
    }
    declaracion.setLinea(String.valueOf(lastLine));
    declaracion.setColumna(String.valueOf(lastColumn));
    listaTablasSimbolos.get(currentHash).add(declaracion);
:}
;

lista_char ::= CHAR:caracter {: 
    RESULT = caracter.toString();
:}
| lista_char:lista COMA CHAR:caracter {: 

    String listaStr = lista.toString() + ", " + caracter.toString();
    RESULT = listaStr;
:}
;

arreglo_char ::= COR_A lista_char:lista COR_C {: 
    String resultado = "[" + lista.toString() + "]";
    RESULT = resultado;
:};

asignacion ::= ID:nombre ASIGN expresion:valor
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            if(valor != null){
                String valorStr = valor.toString();
                validarAsignacionTipo(variable.getTipo(), valorStr, lastLine, lastColumn);
                cod3D(nombre + " = " + valor);
                variable.setValor(valorStr);
            } else {
                variable.setValor("");
            }
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
        RESULT = nombre;
    :}
    | ID:nombre COR_A ENTERO COR_C ASIGN ENTERO:valorArr
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            variable.setValor("arreglo_entero[" + valorArr + "]");
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
        RESULT = nombre;
    :}
    | ID:nombre COR_A ENTERO COR_C ASIGN arreglo_char:valorChar
    {:
        NodoToken variable = buscarID(nombre.toString());
        if(variable != null){
            variable.setValor("arreglo_char");
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       La variable '%s' no ha sido declarada. Línea %d, columna %d.\u001B[0m %n", nombre.toString(), lastLine, lastColumn);
            tieneErrores = true;
        }
        RESULT = nombre;
    :}
    ;
// EXPRESIONES
expresion ::= expresion AND expresion
    | expresion OR expresion
    | NOT expresion
    | expresion_arit op_rel expresion
    | expresion_arit:e {: RESULT = e;:}
    ;

// EXPRESIONES ARITMETICAS
expresion_arit ::= expresion_arit:e1 MAS termino:e2
        {:
            String tipo1 = obtenerTipoExpresion(e1);
            String tipo2 = obtenerTipoExpresion(e2);
            String temp;

            if (sonTiposCompatibles(tipo1, tipo2)) {
                if (tipo1.equals("float") || tipo2.equals("float")) {
                    temp = nuevaTempFloat();
                } else {
                    temp = nuevaTempInt();
                }
                cod3D(temp + " = " + e1 + " + " + e2);
                RESULT = temp;
            } else {
                System.err.printf("\u001B[31m XXX Error semántico XXX : Tipos incompatibles en suma: '%s' y '%s'. Línea %d, columna %d.\u001B[0m%n",
                    tipo1, tipo2, lastLine, lastColumn);
                tieneErrores = true;
                RESULT = "error";
            }
        :}
    | expresion_arit:e1 MENOS termino:e2
        {:
            String tipo1 = obtenerTipoExpresion(e1);
            String tipo2 = obtenerTipoExpresion(e2);
            String temp;

            if (sonTiposCompatibles(tipo1, tipo2)) {
                if (tipo1.equals("float") || tipo2.equals("float")) {
                    temp = nuevaTempFloat();
                } else {
                    temp = nuevaTempInt();
                }
                cod3D(temp + " = " + e1 + " - " + e2);
                RESULT = temp;
            } else {
                System.err.printf("\u001B[31m XXX Error semántico XXX : Tipos incompatibles en resta: '%s' y '%s'. Línea %d, columna %d.\u001B[0m%n",
                    tipo1, tipo2, lastLine, lastColumn);
                tieneErrores = true;
                RESULT = "error";
            }
        :}
    | termino:t {: RESULT = t; :}
    ;

termino ::= factor POR factor
    | factor DIV factor
    | factor DIV_ENT factor
    | factor MOD factor
    | factor:f {: RESULT = f; :}
    ;

factor ::= potencia POT potencia
    | potencia:p {: RESULT = p; :}
    ;

potencia ::= PAR_A expresion PAR_C
    | operando:o {: RESULT = o; :}
    ;
    
//UN OPERANDO ES LA FORMA MÁS SENCILLA DE UNA OPERACIÓN
operando ::= ENTERO:a {: 
    RESULT = a; 
:}
| FLOTANTE:f {: 
    RESULT = f; 
:}
| TRUE1 {: 
    RESULT = "true"; 
:}
| FALSE1 {: 
    RESULT = "false"; 
:}
| CADENA_CHAR:c {: 
    RESULT = c; 
:}
| CADENA:s {: 
    RESULT = s; 
:}
| ID:id {: 
    RESULT = id.toString();
    // Verificar que la variable existe
    NodoToken variable = buscarID(id.toString());
    if (variable == null) {
        System.err.printf("\u001B[31m XXX Error semántico XXX :       Variable '%s' no declarada en expresión. Línea %d, columna %d.\u001B[0m %n", id.toString(), lastLine, lastColumn);
        tieneErrores = true;
    }
:} 
| llamada_funcion:llamada {: 
    RESULT = llamada; 
:}
| elem_arr
| MENOS operando:op {: 
    if (op != null) {
        String resultado = "-" + op.toString();
        RESULT = resultado;
    } else {
        RESULT = null;
    }
:}
| incrementar
| decrementar
;

// OPERADORES RELACIONALES
op_rel ::= MAYOR
    | MENOR
    | MAY_IGU
    | MEN_IGU
    | IGUAL
    | DIF
    ;

// ESTRUCTURAS DE CONTROL 

// TO-DO: arbol sintáctico para condicionales y bucles

condicional ::=
    DECIDE OF
    {:
        // AQUI SE CREA EL SCOPE PARA EL BLOQUE DECIDE
        contadorDecide++;
        String decideScope = currentHash + "_DECIDE_" + contadorDecide;
        crearSubAmbito(decideScope);
        System.out.println(">>> [DEBUG] Inicia ámbito DECIDE: " + decideScope);
        
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = decideScope;

        RESULT = anteriorScope;
    :}
    lista_casos
    cond_else_opt
    END DECIDE
    {:
        // recuperar el scope en el que estaba antes
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito DECIDE, regresando a: " + currentHash);
    :}
    ;

lista_casos ::= caso
              | lista_casos caso
              ;

caso ::=
    PAR_A expresion PAR_C FLECHA
    {:
        // SCOPE POR CADA CASO
        contadorCase++;
        String caseScope = currentHash + "_CASE_" + contadorCase;
        crearSubAmbito(caseScope);
        System.out.println(">>> [DEBUG] Inicia ámbito CASE: " + caseScope);

        String anteriorScope = currentHash;
        currentHash = caseScope;
        RESULT = anteriorScope;
    :}
    bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito CASE, regresando a: " + currentHash);
    :}
    ;

cond_else_opt ::=
      /* vacío */
    | ELSE FLECHA
    {:
        contadorElse++;
        String elseScope = currentHash + "_ELSE_" + contadorElse;
        crearSubAmbito(elseScope);
        System.out.println(">>> [DEBUG] Inicia ámbito ELSE: " + elseScope);

        String anteriorScope = currentHash;
        currentHash = elseScope;
        RESULT = anteriorScope;
    :}
      bloque
    {:
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito ELSE, regresando a: " + currentHash);
    :}
    ;

bucle_loop ::=
    LOOP
    {:
        // Crear scope de tabla de símbolos 
        contadorLoop++;
        String loopScope = currentHash + "_LOOP_" + contadorLoop;
        crearSubAmbito(loopScope);
        cod3D("\n" + currentHash + "_loop_" + contadorLoop + ":");


        System.out.println(">>> [DEBUG] Inicia ámbito LOOP: " + loopScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = loopScope;

        // Codigo intermedio

        RESULT = anteriorScope;
    :}
    lista_sentencias
    EXIT WHEN expresion:e1 FIN_E
    {: 
        // Codigo intermedio NO HAY VALIDACION SEMANTICA
        cod3D("if " + e1 + " goto " + currentHash + "_endloop_" + contadorLoop);
    :}
    END LOOP FIN_E
    {:
        // Codigo intermedio
        cod3D("goto " + currentHash + "_loop_" + contadorLoop);
        cod3D(currentHash + "_endloop_" + contadorLoop + ":");

        // Restaurar el scope previo
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito LOOP, regresando a: " + currentHash);
    :}
    ;

bucle_for ::=
    FOR1
    asignacion:e
    step ENTERO:valor
    direccion:dir expresion:limite
    {:  

        contadorFor++;
        String forScope = currentHash + "_FOR_" + contadorFor;
        cod3D(forScope + ":");
        String temporalContador = nuevaTempInt();
        String temporalLimite = nuevaTempInt();
        String temporalValidacion = nuevaTempInt();
        cod3D(temporalContador + " = " + e);
        cod3D(temporalLimite + " = " + limite);
        int numeroStep = Integer.parseInt(valor.toString());
        if(numeroStep > 0){
            if (dir.equals("downto")) {
                cod3D(temporalValidacion + " = " + temporalContador + " < " + temporalLimite);
            } else {
                cod3D(temporalValidacion + " = " + temporalContador + " > " + temporalLimite);
            }
        } else {
            System.err.printf("\u001B[31m XXX Error semántico XXX :       El valor de STEP debe ser mayor que 0. Línea %d, columna %d.\u001B[0m %n", lastLine, lastColumn);
            tieneErrores = true;
        }    
        
        crearSubAmbito(forScope);
        cod3D("if " + temporalValidacion + " goto " + forScope + "_endfor_" + contadorFor);
        if (dir.equals("downto")) {
            cod3D(e + " = " + temporalContador + " - " + valor);
        } else {
            cod3D(e + " = " + temporalContador + " + " + valor);
        }
        System.out.println(">>> [DEBUG] Inicia ámbito FOR: " + forScope);
        // Guardar el scope anterior
        String anteriorScope = currentHash;
        currentHash = forScope;
        RESULT = anteriorScope;
        
    :}
    DO bloque 
    {:  

        String forFinal = currentHash + "_endfor_" + contadorFor;
        cod3D("goto " +currentHash);
        cod3D(forFinal+ ":");
        // Recupera el scope anterior
        currentHash = (String) RESULT;
        System.out.println(">>> [DEBUG] Fin ámbito FOR, regresando a: " + currentHash);
    :}
    
    ;

step ::= /* vacío */
       | STEP
       ;

direccion ::= TO:to {: RESULT = to.toString(); :}
            | DOWNTO:downto {: RESULT = downto.toString(); :}
            ;

//++++++++++++++++++++++++++++++++ARREGLOS+++++++++++++++++++++++++++++

lista_elementos_arreglo_entero ::= ENTERO:entero {: 
    // Primer elemento
    ArrayList<String> elementos = new ArrayList<>();
    elementos.add(entero.toString());
    RESULT = elementos;
    System.out.println(">>> [DEBUG] Primer elemento del arreglo: " + entero);
:}
| lista_elementos_arreglo_entero:lista COMA ENTERO:entero {: 
    // Agregar elemento a la lista existente
    if (lista != null && lista instanceof ArrayList) {
        ArrayList<String> elementosLista = (ArrayList<String>) lista;
        elementosLista.add(entero.toString());
        RESULT = elementosLista;
        System.out.println(">>> [DEBUG] Agregando elemento al arreglo: " + entero + ", total: " + elementosLista.size());
    } else {
        // Si por alguna razón la lista no es válida, crear una nueva
        ArrayList<String> elementos = new ArrayList<>();
        elementos.add(entero.toString());
        RESULT = elementos;
        System.out.println(">>> [DEBUG] Creando nueva lista con elemento: " + entero);
    }
:}
;